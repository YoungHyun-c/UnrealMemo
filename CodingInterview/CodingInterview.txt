============================================================

- 매일 매일 회사 가기전까지 하루에 최소 2시간 이상씩 투자할 것.
 ㄴ 틈틈이 확인할 것.

 01. 코딩 테스트 준비.
  ㄴ 과정 끝날쯤까지 목표는 2단계 후반 / 골드
  ㄴ 프로그래머스 
  ㄴ 백준
 02. 칸 아카데미 : https://ko.khanacademy.org/
  고1 수학 목표.
 03. 영어공부 : https://hanmadiro.com/
  독해 공부


언어 50%
자료구조 알고리즘 30퍼
선형, 수학 요소 20퍼

질문에 대한 답을 못할시 답 못한 문제 30초 ~ 1분 발표.

============================================================

- 코딩 인터뷰

00. 자기 소개?
ㄴ 1분.
-> 장 단점은 얘기하는 것은 별로.
-> 단점은 중화시키고, 중위적으로 표현할 것.
-> 프로그래머적으로 엮어서 소개해야 공감, 스토리 라인 형성.
안녕하세요. 저는 OO회사에 지원하게 된 홍영현 입니다. 저는 이전 회사에서 가스탱크, 지하 수로, 터널 등 다양한 장소로 출장을 다니면서,
현재 우리가 살고 있는 세상을 데이터화하는 작업이 얼마나 중요한지 알게 되었습니다. 다양한 시설물에 센서를 부착해 데이터를 수집하고,
이를 3D 평면화하거나 가상공간에서 관리하는 경험을 했었습니다. 이 과정에서 현실을 가상 세계로 옮겨와 관리하고 분석하는 기술의
발전에 깊은 관심을 갖게 되었고, 이를 구현하는데 가장 적합한 방법이 객체지향 프로그래밍이라는 것을 깨달았습니다.
이러한 경험을 바탕으로 저는 게임프로그래밍을 통해 현실 세계와 가상세계를 연결하고, 더욱 복잡하고 정교한 시스템을 구현하는 일을 하고 싶다는
열망을 갖게 되었습니다. OO 회사가 제공하는 혁신적인 게임 개발 환경과, 다양한 시도가 이 회사의 장점이라고 생각하여 지원하게 되었고,
더욱 발전 시키고 싶습니다.

01. 입사 동기?
ㄴ 왜 널 뽑아야 하나? 어필?
※  성장 이력. 개념적으로 지식을 갖고, 넓게 생각한다는걸 이력해야 한다.
  저는 다양한 경험을 통해서 성장을 해왔으며, 코딩을 배울 때 나무를 보는 것이 아닌 숲을 보라는 말을 들었습니다. 그 말은 즉슨
 문제를 해결할 때 우선적으로 부딪혀 보는 것이 아닌 넓고 유연한 사고를 바탕으로 접근하는 것이 중요하다는 것을 배웠습니다.
  그리고 제가 책을 읽고 감명깊었던 글귀가 있는데, 어린왕자 책에서, '큰 배를 만들고 싶으면 나무와 연장을 주고 배 만드는 법을
 가르치기 전에 먼저 바다에 대한 동경을 심어주면 그 사람 스스로 배를 만드는 법을 찾아낼 것이다' 라는 말이 정말 마음에 들었습니다.
 코딩을 통해 단순히 게임 만드는 것을 배운 것이 아닌 제가 동경하는 게임을 만듬으로써 저는 팀을 위해 가독성 및 재사용성이 좋은 코딩을
 만들기 위해 노력해 왔음으로 저를 뽑아주시면 이 회사에 큰 기여가 될 것이라고 생각합니다.


02. 야근 여부와 의지에 대해
※  회사의 사정과 배워야 할께 많기 때문에 회사의 사정에 맞춰 충분히 가능함을 어필.
 회사의 상황과 프로젝트 진행에 맞춰 필요한 경우에는 야근도 충분히 가능합니다. 현재 제가 회사내의 규정 및 시스템 등 배워야 할 부분도 많기
 때문에 추가적인 시간이 필요하다면 그에 맞춰 유연하게 대응할 준비가 되어 있습니다. 회사의 목표 달성과 제 개인적인 성장 모두 중요하다고
 생각하기 때문에, 회사의 일정에 맞춰 최선을 다하겠습니다.

03. 성격의 장 / 단점?
장점 -> 원활한 협업 관계, 소통을 어필.
단점 -> 중위적으로 푼다.
※  혹시 카피바라라는 동물에 대해서 알고계신가요? 카피바라는 다양한 동물들과의 친화력을 갖고있는 것으로 잘 알려져 있습니다.
카피바라가 다양한 동물들과 잘 어울리며 평화롭게 지내는 것 처럼, 저는 팀 내에서 다양한 사람들과 원활하게 소통하며 협업하는 것을
중요하게 생각합니다. 서로의 강점을 인정하고 존중하며 조화를 이루는 환경에서 최고의 성과를 낼 수 있다고 믿고있습니다.
이처럼 저는 긍정적인 소통과 협업을 통해 팀의 목표를 함께 달성할 수 있는 능력이 저의 큰 장점이라고 생각합니다.
 그래서 단점으로는 협업을 중요하게 생각하다 보니, 모든 의견을 충분히 고려하는 과정에서 결정을 내리는데 시간이 걸릴 수 있습니다.
하지만 이를 통해 다양한 관점을 포용하고, 더 나은 결정을 내릴 수 있다고 생각합니다. 그래서 저는 빠른 의사결정이 필요할 때는
우선순위를 정해 효율성을 높이도록 노력하고 있습니다.

04. 외국어 할 줄 아는가? (중 / 대)
ㄴ 프로그램 얘기가 무조건 나와야 한다.
-> 제가 외국어를 말하기 수준은 어려울 수 있으나, 업무 상으로 필요한 독해력은 가능하다고 생각한다 어필.
※  제가 외국어를 원어민과 대화할 정도의 수준으로 말하기는 어려우나, 업무 상으로 필요한 코딩 스탠다드나, C++ Reference 사이트를 참고하여, 남들에게
설명할정도의 독해력을 가지고 있습니다.

05. 절차지향과 객체지향의 차이점에 대해 설명해 보시오.
※  절차지향 프로그래밍이란 순차적인 명령을 기반으로 프로그램이 실행되며, 데이터와 함수는 별도로 취급됩니다. 대표적인 언어로는
C언어가 있습니다.
※  객체지향 프로그래밍이란 프로그램을 객체라는 단위로 나누어 개발하는 것 입니다. 객체는 데이터(속성)와 그 데이터를 처리하는
매서드(함수)를 함께 묶어 관리합니다. 프로그램이 동작할 때 객체들이 서로 상호작용하며 문제를 해결해 나갑니다. 대표적인 언어로는
C++, Python 등이 있습니다.

06. 객체지향 4대 특징?
ㄴ
1. 캡슐화
※  서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호 하는 것을 캡슐화라고 합니다.

2. 상속성
※  기존의 클래스를 재활용하여, 새로운 클래스를 만들어 사용하는 것이며, 이는 OOP 특징인 캡슐화를 보존하며 사용할 수 있습니다.

3. 다형성
※  상속받은 매서드나 클래스가 서로 다른 클래스에서 다양한 방식으로 동작하게 하는 것을 다형성이라고 합니다.
대표적으로 오버라이드(클래스)와 오버라이딩(함수, 매서드)의 차이를 예를 들 수 있습닌다.

4. 추상화
※  불필요한 부분을 제거하고, 공통적인 부분과 특정 특성을 분리 추출하여 재조합과 재구성 하는 것을 추상화라고 합니다.
-> 추상화를 통해서 코드의 재사용성과 가독성이 높아지고 유지보수에 있어 많은 시간을 절약할 수 있습니다.

07. 객체지향 5대 설계 원칙에 대해 설명해 보시오.
ㄴ
SRP -> 단일책임의 원칙. -> 결합도는 낮추고, 응집도는 높이는 것입니다.
결합도는 모듈간의 상호 의존 정도, 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성이라고 얘기할 수 있다.
OCP -> 개방-폐쇄의 원칙. -> 자신의 확장성에는 열려있고, 주변의 변화에 있어서는 닫혀있어야 된다는 것입니다.
LSP -> 리스코프 치환의 원칙 -> 하위 객체는 언제든지 상위 객체로 대체 될 수 있다는 것입니다. 이를 업캐스팅이라고 합니다.
ISP -> 인터페이스 분리의 원칙. -> 자신이 사용하지 않는 함수나 매서드에 의존 관계를 맺지 않는 것입니다.
DIP -> 의존관계 역전의 원칙. -> 자신보다 변화하기 쉬운 것에는 의존 관계를 맺지 않는 것입니다.

08. 프레임워크와 라이브러리 차이점에 대해 알고 있는지?
ㄴ 1. 미주알 고주알..... 2. 엔진 팔이  3. 아무말 대잔치
ㄴ 제어 (IOC : 제어의 역전)
사용자에 의해 제어를 맡기냐, 라이브러리에 제어를 맡기냐 차이.
차이점
※ 프레임워크는 애플리케이션의 구조와 흐름을 제어하며, 일관된 개발 패턴을 제공합니다,
 반면에 라이브러리는 특정기능을 쉽게 사용할 수 있도록 도와주며, 개발자가 전체 흐름을 제어할 수 있게합니다.
-> 프레임워크 -> 구조가 이미 정의되어 있기 때문에, 유연성이 상대적으로 낮다. 개발자는 프레임워크의 규칙과 관습을
따라야 하며, 특정한 방식으로 개발을 해야 한다.
-> 라이브러리 -> 프로그램의 제어 흐름이 개발자에게 있기 때문에 유연성이 높다. 개발자는 자신이 필요로 하는 라이브러리의
기능만 선택해서 사용할 수 있고, 프로그램의 구조나 흐름은 자유롭게 설계할 수 있다.

09. 메가맨 해봤는지? 해봤다면 이와 비슷한 장르의 충돌처리는 어떻게 할건지 본인의 의견 제시.
ㄴ 픽셀 충돌.
※ 우선 캐릭터와 적과의 충돌처리는 계산량이 적고 직관적으로 구현 가능한 AABB 박스를 통해서 처리를 할 것이며,
캐릭터가 맵의 경사로를 타야 하는 경우에는 좀더 정확한 픽셀충돌을 사용할 것이며, 간단한 픽셀충돌 방식을 채용할 것입니다.
간단한 픽셀충돌이란, 두 개체의 박스 충돌을 감지 후, 박스 안의 실제 픽셀 데이터만을 비교하는 것입니다
1.정확한 픽셀충돌(Exact Pixel Collision) 두 이미지의 실제 픽셀 데이터를 비교하여 충돌을 감지.
-> 가장 정확하지만 이미지의 실제 형태와 크기를 반영하여 충돌을 감지하여 연산이 복잡하고 시간이 많이 걸릴 수 있음.
2.간단한 픽셀충돌(Simplified Pixel Collision)
-> 두 개체의 박스 충돌 감지 후, 박스 안의 실제 픽셀 데이터만을 비교. 즉 박스 충돌이 발생한 경우에만 충돌 검사.
-> 따라서 박스 충돌이 일어나지 않는 경우 픽셀 충돌을 검사하지 않기 때문에 일부 충돌을 놓칠 수 있다.
3.픽셀-좌표 충돌 감지
-> 캐릭터나 적의 픽셀 데이터를 기반으로 충돌 위치를 계산하는 방식.
-> 충돌 위치를 더욱 정밀하게 계산 하지만, 성능 저하를 초래.
4.컬러기반 충돌 감지
-> 픽셀의 색상 정보를 이용하여 충돌을 감지, 투명하지 않은 픽셀의 색상 값을 비교하여 충돌 여부를 판단.
-> 색상 기반으로 쉽게 구현 가능하며, 색상 정보가 겹치는 경우 정확도가 떨어질 수 있다.

10. 메모리란 : 설명해 주시오.
ㄴ 라이트 (Ram휘발성) / 딥
-> 데이터를 저장하는 장치로서, 주 저장장치와 보조저장장치가 있다.
-> CPU와 레지스터 클러스터 관계?
-> 스트림? 코어클럭 분할
-> 쓰레드? -> 언리얼 시작창을 누르기만 해도 쓴거다.
※  프로그래머가 필요에 의해 데이터를 저장하는 공간으로써, 레지스터, 캐시 메모리, 주기억장치, 보조기억장치가 있습니다.
레지스터 -> 용량은 작고, 가격은 비싸지만 CPU에 직접 연결되어 있기 때문에 연산 속도가 기억 장치들에 비해 빠릅니다.
캐시메모리 -> 데이터를 미리 복사해두는 임시 저장공간을 의미합니다.
주기억장치 -> 대표적으로 RAM이 있습니다. 데이터를 읽거나 쓰는 것이 가능하며, 응용 프로그램, 운영체제 등을 불러와 CPU가
			 작업할 수 있도록 하는 기억장치입니다. 대신 휘발성 메모리로서 전원이 끊어지면 데이터가 전부 지워집니다.
보조기억장치 -> 대표적으로 HDD와 SSD가 있습니다.
OS에 대한 메모리 컨택스 (메모리 누수)에 대해 설명할 수 있음 Ok

★★★
11. 직원들이 퇴근하고 혼자 있을 때 문제점 발견 / 본인은 어떻게 할것인가? (심야 / 새벽)
ㄴ. 내가 책임질 수 있는 일이 아니라면, 상사에게, 팀장에게 보고를 하여 알리는게 우선이다.
※ 우선적으로 제가 책임질 수 있는 일이 아니라면, 직장 상사에게, 혹은 팀장님에게 현재 상황에 어떤 문제가 있는지 정확히 보고를
하여 알리는 것이 가장 좋다고 생각합니다.

12. 본인의 성향? (리더? / 부하? / 참모?)
ㄴ 참모가 제일 무난하다.
※  저의 성향으로는 단순히 상사의 지시에 따르며 하나만 하는 부하직원이 아닌, 상사의 지시에 1개를 알려주면 10가지를 배우며,
상황에 따라 어떠한 방법이 특정 상황에 가장 적합할지 고민하고 행동하기에 참모에 비슷하다고 생각합니다.

13. 자기보다 나이가 어린 사람 / 혹은 아주 많은 사람 아래에서 일 할 수 있나?
ㄴ + 텃세 / 부당 상황.
※  저는 일 할 수 있다고 생각합니다. 왜냐하면 저는 일하는것에 있어 나이는 숫자에 불과하다고 생각하기 때문에
저보다 일을 잘한다면 당연히 저의 선배가 될 수 있다고 생각합니다. 그리고 텃세와 부당상황에 대해서는 개인적으로 해결할 수 있는
문제가 아니라면, 상사 혹은 팀장님께 도움을 요청하여 해결하도록 노력할 것 입니다.

★★★
14. 구조체 / 클래스 차이점?
ㄴ C++ 하고 C#을 나눠서 얘기하면 가산점. (언리얼을 썼기 때문에)
※  구조체와 클래스는 C++ 과 C#에서 모두 사용되며, 두 언어에서의 특성과 차이점이 있습니다.
먼저 C++ 에서는 기본 접근 제어 지시자가 구조체에서는 public, 클래스에서는 private 입니다.
그리고 구조체는 보통 값 타입으로 사용되고, 클래스는 참조 타입으로 사용 됩니다.
C#에서는 접근제어 지시자가 기본적으로 둘다 private 입니다.
-> 심화? 구조체는 값 타입으로 동작하며, 기본적으로 스택에 할당됩니다. 클래스는 참조 타입으로 동작하며, 힙에 할당됩니다.
구조체는 상속을 지원하지 않으며, 소멸자를 정의할 수 없습니다. 클래스는 상속과 소멸자를 지원한다.

15. LifeCycle 설명? (전 / 지 / 동) / 동작 방식?
ㄴ 전역변수, 지역변수, 동적할당.
-> Allocate -> Release -> Memory Pool + {}
ㄴ 변수의 메모리가 확보된 (Allocate) 시점부터 해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점
ㄴ 기본적으로 변수는 자신이 선언된 Scope 내에서 생성되고 소멸이 된다.
ㄴ 일반적으로 전역 -> 어플리케이션의 주기 / 지역 -> 함수의 주기
※  변수의 LifeCycle(생명주기)는 변수의 생성, 사용, 소멸 과정에 따라 다릅니다. 변수의 메모리가 확보된 (Allocate) 시점부터
해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점입니다. 기본적으로 변수는 자신이 선언된 Scope 내에서
생성되고 소멸 됩니다.

ex) {}

for(size_t i = 0; i < length; i++)
{
	if()
	{
		/// 주석 내용~ {} 알려줄때는 / 3개쓰기
		{

		}
	}
}

16. 현재 읽고 있는 전공책.
 ㄴ 모던 시리즈(생각 잘하고 말하도록.) 드래곤, 스컬, 물, 노을, 공룡
※  현재 읽고 있는 책으로는 다이렉트는 드래곤 혹은 물방울 책을 참고하고 있고, CS 지식으로는 공룡책을 참고하여 공부하고있습니다.


17. A* 알고리즘 알고 있는지? 알고 있다면 동기화 기법? (2D 에서 쓸일이 많다.)
ㄴ 다익스트라 원리 채용한 알고리즘
 ㄴ 현재까지 가장 최소의 비용으로 도달한 지점부터 탐색한다.
ㄴ f(x) = g(x) + h(x)
 ㄴ 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색.
ㄴ g(x) : 현재 상태 비용
ㄴ h(x) : 현재에서 다음 휴리스틱
장점 : 쉽다. 이해하기 편하다. 자료구조를 안탄다. (어느것이든 돼서)
단점 : 느리다. 최적화를 해야 한다.
동기화 기법 : 구역을 나눠서 연산하는 방법, JPS(가지치기, 점프, 리서치) 등 다양한 기법이 있다.
개선안 : JPS(가지치기, 점프, 리서치) A* 의 개선판. 훨씬 빠름. (단점 : 중간중간이나, 듬성듬성 오브젝트가 많으면, 프로그램이 뻑 날 수 이씀)
※  A* 알고리즘이란 -> 그래프 탐색 알고리즘 중 하나로,
자신의 주변 노드를 탐색하여 갈 수 있는지 확인하고, 목표지점까지의 비용을 계산하여, 최소가 되는, 즉 최단 경로를 찾기 위해 사용되는 알고리즘입니다.
특히 2D 경로 탐색에서 주로 사용되며, 다익스트라 알고리즘과 최적 우선탐색의 조합으로 목표에 도달하는 비용을 예측하고 효율적으로
경로를 찾습니다. 공식으로는 현재상태비용, 현재에서 다음휴리스틱, 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색하는 것입니다.
개선안으로는 구역을 나눠서 연산하는 방법(다중 레벨 경로 탐색)과 JPS가 있습니다.

구역 나눠서 연산
※ 맵을 여러 구역으로 나누어 구역 간의 경로 정보를 미리 계산하여 큰 범위에서의 탐색을 줄임으로써 성능을 개선하는 방식입니다.
동작방식
1.맵 구분: 구역을 나눠서 연산하는 방법은 전체 맵을 여러 개의 작은 구역으로 나누고 구역들은 일종의 추상화된 노드라고 생각 하여
작은 구역들의 경계에서 이동 가능한 포탈 노드를 정의할 수 있습니다.
2.고수준 경로 탐색: 최단 경로를 구할 때 먼저 구역 간의 큰 그림에서 경로를 탐색합니다. 이때 구역 자체를 노드로 보고 경로를 찾습니다.
3.저수준 경로 탐색: 고수준에서 찾은 경로를 기준으로 세부적으로 각 구역 내부에서 최단 경로를 탐색합니다.

JPS(Jump Point Search)
※  불필요한 노드확장을 생략하고, 탐색할 필요가 없는 경로를 빠르게 건너뛰도록 최적화한 알고리즘입니다. A* 알고리즘은 모든 인접노드를
탐색하며 확장해 나가지만, JPS는 그리드에서 특정 점프포인트들만 탐색합니다. 즉, 불필요한 노드 확장을 피하고, 경로의 핵심적인
전환점들만 찾아 나가는 방식입니다.
동작방식
1.일반화된 이동: JPS는 처음부터 모든 방향으로 최대한 멀리 이동합니다. 그리드 상에서 상하좌우 및 대각성 방향으로 최대한 멀리 이동 후
특정 조건에 따라 탐색을 중단하거나 계속 확장합니다.
그리드란? (행과 열로 이루어진 사각형, 즉 격자형태로 이루어진 구조를 말하며, 2D경로 탐색이나 시뮬레이션에 자주 사용됩니다.)
2.중간 노드 생략: 경로 상에 중요하지 않은 중간 노드들은 건너뛰고, 경로의 전환점이나 중요한 포인트(점프)에만 도달할 때까지 이동합니다.
점프포인트는 경로가 꺽이거나 회전해야 하는 중요한 지점. JPS는 이 점프 포인트만 탐색 대상으로 사용
3.휴리스틱 사용: A* 알고리즘의 공식을 사용하지만, 확장할 때 불필요한 중간 노드를 배제하여 성능을 높입니다.

블랙 A* (블록A*)
※  그리드의 작은 섹션에 있는 모든 가능한 경로를 포함하는 로컬 거리 데이터베이스를 생성합니다.
이 데이터베이스를 참조하여 조각별 임의 각도 경로를 빠르게 찾습니다.
모든 각도 경로 계획 알고리즘은 경로의 회전이 모든 각도를 가질 수 있도록 하면서 그리드 맵의 두 지점 사이의 유클리드 최단경로를
검색하는 경로찾기 알고리즘입니다. 그로 인해 열린 공간을 직접 통과하고 상대적으로 회전이 적은 경로가 생성 됩니다.
https://en.wikipedia.org/wiki/Any-angle_path_planning#A*-based

★★★
18. 포트폴리오를 제작하면서 다른 사람들부터 이런점은 내가 더 낫다? 혹은 어필하고 싶은 기능
ㄴ 무기를 만들때 추상 클래스를 활용하여 ~ 추가할 때 좀 더 용이하게 만들었다 등
※ 제 포트폴리오를 통해서 남들보다 더 낫다고 생각하는 것은, 추상 클래스를 활용하여, 확장성과 유지보수성을 높인 설계에 있습니다.
예를 들어, 여러 개의 비슷한 기능을 가진 스킬들을 관리하는 시스템에서, 공통된 인터페이스와 기본 동작을 추상 클래스에 정의해두면,
새로운 객체를 추가할 때마다 전체 코드를 수정할 필요 없이 새로운 클래스에서 필요한 부분만 구현하면 되어 재사용성을 극대화하고
중복된 코드를 줄여주며, 유지보수에 좋게 설계했다고 생각합니다.


// 9 / 13
19. A* 2D / A* 3D 차이점에 대해 알고 있는지?
-> 2D는 현재 보여지는 영역(카메라가 보는)모든 영역을 검사.
-> 3D에서는 마우스로 입력 받을때 확인해야되는데, 캐릭터 반경에 원을 만들어두고, 반경까지만 검사. (처음에 벽을 찍어도 일단은 가는 이유)
   EPS?, 다익스트라.

※ 2D 에서는 X,Y 좌표를 사용하여, 4방향 또는 8방향으로 이동하며 현재 2차원 평면에서 보여지는 모든 영역을 검사하지만,
3D에서는 3차원 공간을 사용하여 6방향(상하좌우앞뒤) 또는 26방방향으로 이동하며 검사합니다.
그리고 거리계산으로는 2D는 멘해튼거리(상하좌우), 유클리드거리(대각선)로 계산, 3D는 체비셰프 거리(모든 방향)까지 계산합니다.
EPS란(Enhanced Pathfinding System)
->A* 알고리즘의 성능을 향상시키기 위한 강화된 경로 탐색 시스템입니다. 기능으로는 향상된 휴리스틱, 지역적 최적화, 동적 맵 업데이트.
다익스트라 알고리즘이란
-> 가중치가 있는 그래프에서 최단 경로를 찾기 위한 알고리즘입니다. A* 알고리즘과의 차이로는 휴리스틱 함수를 사용하지 않으며,
모든 경로를 동일하게 고려하여 최단경로를 찾습니다. 탐색 방식으로는 우선순위 큐를 사용하여 탐색하며 모든 노드의 최단 거리를 계산합니다.
EPS vs 다익스트라 알고리즘
※  1. EPS와 A*는 휴리스틱 사용하여 효율성을 높였으며, 다익스트라는 휴리스틱 사용 X
-> 2. 실시간 업데이트 EPS는 동적 맵에서 실시간 업데이트를 지원, 다익스트라는 정적인 맵에서 작동
-> 3. 성능 A*와 EPS는 일반적으로 다익스트라 알고리즘보다 더 빠르게 경로를 찾기 가능.


20. STL 정의?
ㄴ 자료구조, 알고리즘을 템플릿화 시켜놓은 라이브러리.
※  표준 템플릿 라이브러리로, 다양한 자료구조와 알고리즘을 제공하는 것 입니다.
주로 컨테이너 (vector, list, deque, set, map 등이 있습니다.),
반복자(컨테이너 요소에 접근하고 순회, 반복자는 포인터처럼 작동하며, 요소들에 차례로 접근할 수 있게 해줌),
알고리즘(정렬, 탐색, 복사 등의 작업을 수행하는 함수)이 있습니다.

21. 본인의 코딩 스타일은 어떤가?
ㄴ 프로토타입을 먼저 작성한다.
※ 제 코딩 스타일은 객체지향적 프로그래밍을 중요시하여, 코드를 캡슐화 하여 데이터를 보호하고, 재사용하기 위해 상속,
다양한 상황에서 유연하게 동작하기 위해 다형성, 그리고 복잡한 로직을 단순화하고, 코드의 가독성을 높이기 위해 추상화를 적용하여
유지보수성이 뛰어난 코드를 작성하기 위해 노력합니다.

22. 참고하는 사이트?
ㄴ 마이크로 소프트 도큐먼트, C++ 레퍼런스, C++ 스택오버플로우
※ 제가 참고하는 사이트로는, 마이크로 소프트 도큐먼트, C++ 레퍼런스가 있습니다.

언리얼에 들어간 DirectX의 개념은 공부를 했다.

23. 디자인 패턴에 대해 아는가?
ㄴ 프로그래머들이 개발하면서 발생하는 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안

24. 알고있는 디자인 패턴? / 혹은 사용해야할 예시를 들어보시오. (GOF)
ㄴ 6 ~ 8개 알고있으면 좋은데, 포폴에서 쓴 디자인 패턴을 얘기하는게 가장 좋다.
컨택스트, 커맨드
싱글톤? 얘기를 할때 엄한거 얘기하지 말고, 언리얼 추상팩토리에 대해 얘기하는게 더 좋다.

24 - 2 템플릿?

25. C / C++ 의 차이점?
ㄴ 객체냐 절차냐는 너무 라이트, 메모리에 대해서 얘기해야됨. 복사, 참조.

- 이 질문은 어렵다..
26. C++ 왜 공부하는가? / 굳이 왜 C++?
ㄴ 내 스타일대로 설명할줄 알아야 할 것 같음.
들어가야할 것(메모리를 직접 관리 할 수 있다. -> 최적화 할 수 있는 것. 컴퓨터의 Low Level로 들어가 구조를 설명 할 줄 아는 것.)
Managed언어, UnManaged언어의 차이를 얘기할 수 도 있겠다.
