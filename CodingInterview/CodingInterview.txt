============================================================

- 매일 매일 회사 가기전까지 하루에 최소 2시간 이상씩 투자할 것.
 ㄴ 틈틈이 확인할 것.

 01. 코딩 테스트 준비.
  ㄴ 과정 끝날쯤까지 목표는 2단계 후반 / 골드
  ㄴ 프로그래머스 
  ㄴ 백준
 02. 칸 아카데미 : https://ko.khanacademy.org/
  고1 수학 목표.
 03. 영어공부 : https://hanmadiro.com/
  독해 공부


언어 50%
자료구조 알고리즘 30퍼
선형, 수학 요소 20퍼

질문에 대한 답을 못할시 답 못한 문제 30초 ~ 1분 발표.

============================================================

- 코딩 인터뷰

00. 자기 소개?
ㄴ 1분.
-> 장 단점은 얘기하는 것은 별로.
-> 단점은 중화시키고, 중위적으로 표현할 것.
-> 프로그래머적으로 엮어서 소개해야 공감, 스토리 라인 형성.
※ 안녕하세요. 저는 OO회사에 지원하게 된 홍영현 입니다. 저는 이전 회사에서 가스탱크, 지하 수로, 터널 등 다양한 장소로 출장을 다니면서,
현재 우리가 살고 있는 세상을 데이터화하는 작업이 얼마나 중요한지 알게 되었습니다. 다양한 시설물에 센서를 부착해 데이터를 수집하고,
이를 3D 평면화하거나 가상공간에서 관리하는 경험을 했었습니다. 이 과정에서 현실을 가상 세계로 옮겨와 관리하고 분석하는 기술의
발전에 깊은 관심을 갖게 되었고, 이를 구현하는데 가장 적합한 방법이 객체지향 프로그래밍이라는 것을 깨달았습니다.
이러한 경험을 바탕으로 저는 게임프로그래밍을 통해 현실 세계와 가상세계를 연결하고, 더욱 복잡하고 정교한 시스템을 구현하는 일을 하고 싶다는
열망을 갖게 되었습니다. OO 회사가 제공하는 혁신적인 게임 개발 환경과, 다양한 시도가 이 회사의 장점이라고 생각하여 지원하게 되었고,
더욱 발전 시키고 싶습니다.

01. 입사 동기?
ㄴ 왜 널 뽑아야 하나? 어필?
성장 이력. 개념적으로 지식을 갖고, 넓게 생각한다는걸 이력해야 한다.
※ 저는 다양한 경험을 통해서 성장을 해왔으며, 코딩을 배울 때 나무를 보는 것이 아닌 숲을 보라는 말을 들었습니다. 그 말은 즉슨
 문제를 해결할 때 우선적으로 부딪혀 보는 것이 아닌 넓고 유연한 사고를 바탕으로 접근하는 것이 중요하다는 것을 배웠습니다.
  그리고 제가 책을 읽고 감명깊었던 글귀가 있는데, 어린왕자 책에서, '큰 배를 만들고 싶으면 연장을 주고 배 만드는 법을
 가르치기 전에 먼저 바다에 대한 동경을 심어주면 그 사람 스스로 배를 만드는 법을 찾아낼 것이다' 라는 말이 정말 마음에 들었습니다.
 코딩을 통해 단순히 게임 만드는 것을 배운 것이 아닌 제가 동경하는 게임을 만듬으로써 저는 팀을 위해 가독성 및 재사용성이 좋은 코딩을
 만들기 위해 노력해 왔음으로 저를 뽑아주시면 이 회사에 큰 기여가 될 것이라고 생각합니다.


02. 야근 여부와 의지에 대해
회사의 사정과 배워야 할께 많기 때문에 회사의 사정에 맞춰 충분히 가능함을 어필.
※ 회사의 상황과 프로젝트 진행에 맞춰 필요한 경우에는 야근도 충분히 가능합니다. 현재 제가 회사내의 규정 및 시스템 등 배워야 할 부분도 많기
 때문에 추가적인 시간이 필요하다면 그에 맞춰 유연하게 대응할 준비가 되어 있습니다. 회사의 목표 달성과 제 개인적인 성장 모두 중요하다고
 생각하기 때문에, 회사의 일정에 맞춰 최선을 다하겠습니다.

03. 성격의 장 / 단점?
장점 -> 원활한 협업 관계, 소통을 어필.
단점 -> 중위적으로 푼다.
※  혹시 카피바라라는 동물에 대해서 알고계신가요? 카피바라는 다양한 동물들과의 친화력을 갖고있는 것으로 잘 알려져 있습니다.
카피바라가 다양한 동물들과 잘 어울리며 평화롭게 지내는 것 처럼, 저는 팀 내에서 다양한 사람들과 원활하게 소통하며 협업하는 것을
중요하게 생각합니다. 서로의 강점을 인정하고 존중하며 조화를 이루는 환경에서 최고의 성과를 낼 수 있다고 믿고있습니다.
이처럼 저는 긍정적인 소통과 협업을 통해 팀의 목표를 함께 달성할 수 있는 능력이 저의 큰 장점이라고 생각합니다.
 그래서 단점으로는 협업을 중요하게 생각하다 보니, 모든 의견을 충분히 고려하는 과정에서 결정을 내리는데 시간이 걸릴 수 있습니다.
하지만 이를 통해 다양한 관점을 포용하고, 더 나은 결정을 내릴 수 있다고 생각합니다. 그래서 저는 빠른 의사결정이 필요할 때는
우선순위를 정해 효율성을 높이도록 노력하고 있습니다.

04. 외국어 할 줄 아는가? (중 / 대)
ㄴ 프로그램 얘기가 무조건 나와야 한다.
-> 제가 외국어를 말하기 수준은 어려울 수 있으나, 업무 상으로 필요한 독해력은 가능하다고 생각한다 어필.
※  제가 외국어를 원어민과 대화할 정도의 수준으로 말하기는 어려우나, 업무 상으로 필요한 코딩 스탠다드나, C++ Reference 사이트를 참고하여, 남들에게
설명할정도의 독해력을 가지고 있습니다.

05. 절차지향과 객체지향의 차이점에 대해 설명해 보시오.
※  절차지향 프로그래밍이란 순차적인 명령을 기반으로 프로그램이 실행되며, 데이터와 함수는 별도로 취급됩니다. 대표적인 언어로는
C언어가 있습니다.
※  객체지향 프로그래밍이란 프로그램을 객체라는 단위로 나누어 개발하는 것 입니다. 객체는 데이터(속성)와 그 데이터를 처리하는
매서드(함수)를 함께 묶어 관리합니다. 프로그램이 동작할 때 객체들이 서로 상호작용하며 문제를 해결해 나갑니다. 하지만 캡슐화와
격리구조로 인해 절차지향 프로그래밍에 비해 상대적으로 속도가 느립니다. 또한, 객체로 사용하기 때문에 추가적인 포인터 크기의
메모리와 연산에 대한 비용이 듭니다.

06. 객체지향 4대 특징?
ㄴ
1. 캡슐화
※  서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호 하는 것을 캡슐화라고 합니다.

2. 상속성
※  기존의 클래스를 재활용하여, 새로운 클래스를 만들어 사용하는 것이며, 이는 OOP 특징인 캡슐화를 보존하며 사용할 수 있습니다.

3. 다형성
※  상속받은 매서드나 클래스가 서로 다른 클래스에서 다양한 방식으로 동작하게 하는 것을 다형성이라고 합니다.
대표적으로 오버라이드(클래스)와 오버라이딩(함수, 매서드)의 차이를 예를 들 수 있습닌다.

4. 추상화
※  불필요한 부분을 제거하고, 공통적인 부분과 특징 특성을 분리 추출하여 재조합과 재구성 하는 것을 추상화라고 합니다.
-> 추상화를 통해서 코드의 재사용성과 가독성이 높아지고 유지보수에 있어 많은 시간을 절약할 수 있습니다.

07. 객체지향 5대 설계 원칙에 대해 설명해 보시오.
ㄴ
SRP -> 단일책임의 원칙. -> 결합도는 낮추고, 응집도는 높이는 것입니다.
결합도는 모듈간의 상호 의존 정도, 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성이라고 얘기할 수 있다.
OCP -> 개방-폐쇄의 원칙. -> 자신의 확장성에는 열려있고, 주변의 변화에 있어서는 닫혀있어야 된다는 것입니다.
LSP -> 리스코프 치환의 원칙 -> 하위 객체는 언제든지 상위 객체로 대체 될 수 있다는 것입니다. 이를 업캐스팅이라고 합니다.
ISP -> 인터페이스 분리의 원칙. -> 자신이 사용하지 않는 함수나 매서드에 의존 관계를 맺지 않는 것입니다.
DIP -> 의존관계 역전의 원칙. -> 자신보다 변화하기 쉬운 것에는 의존 관계를 맺지 않는 것입니다.

08. 프레임워크와 라이브러리 차이점에 대해 알고 있는지?
ㄴ 1. 미주알 고주알..... 2. 엔진 팔이  3. 아무말 대잔치
ㄴ 제어 (IOC : 제어의 역전)
사용자에 의해 제어를 맡기냐, 라이브러리에 제어를 맡기냐 차이.
차이점
※ 프레임워크는 어플리케이션의 구조와 흐름을 제어하며, 일관된 개발 패턴을 제공합니다,
 반면에 라이브러리는 특정기능을 쉽게 사용할 수 있도록 도와주며, 개발자가 전체 흐름을 제어할 수 있게합니다.
-> 프레임워크 -> 구조가 이미 정의되어 있기 때문에, 유연성이 상대적으로 낮다. 개발자는 프레임워크의 규칙과 관습을
따라야 하며, 특정한 방식으로 개발을 해야 한다.
-> 라이브러리 -> 프로그램의 제어 흐름이 개발자에게 있기 때문에 유연성이 높다. 개발자는 자신이 필요로 하는 라이브러리의
기능만 선택해서 사용할 수 있고, 프로그램의 구조나 흐름은 자유롭게 설계할 수 있다.

09. 메가맨 해봤는지? 해봤다면 이와 비슷한 장르의 충돌처리는 어떻게 할건지 본인의 의견 제시.
ㄴ 픽셀 충돌.
※ 우선 캐릭터와 적과의 충돌처리는 계산량이 적고 직관적으로 구현 가능한 AABB 박스를 통해서 처리를 할 것이며,
캐릭터가 맵의 경사로를 타야 하는 경우에는 좀더 정확한 픽셀충돌을 사용할 것이며, 간단한 픽셀충돌 방식을 채용할 것입니다.
간단한 픽셀충돌이란, 두 개체의 박스 충돌을 감지 후, 박스 안의 실제 픽셀 데이터만을 비교하는 것입니다
1.정확한 픽셀충돌(Exact Pixel Collision) 두 이미지의 실제 픽셀 데이터를 비교하여 충돌을 감지.
-> 가장 정확하지만 이미지의 실제 형태와 크기를 반영하여 충돌을 감지하여 연산이 복잡하고 시간이 많이 걸릴 수 있음.
2.간단한 픽셀충돌(Simplified Pixel Collision)
-> 두 개체의 박스 충돌 감지 후, 박스 안의 실제 픽셀 데이터만을 비교. 즉 박스 충돌이 발생한 경우에만 충돌 검사.
-> 따라서 박스 충돌이 일어나지 않는 경우 픽셀 충돌을 검사하지 않기 때문에 일부 충돌을 놓칠 수 있다.
3.픽셀-좌표 충돌 감지
-> 캐릭터나 적의 픽셀 데이터를 기반으로 충돌 위치를 계산하는 방식.
-> 충돌 위치를 더욱 정밀하게 계산 하지만, 성능 저하를 초래.
4.컬러기반 충돌 감지
-> 픽셀의 색상 정보를 이용하여 충돌을 감지, 투명하지 않은 픽셀의 색상 값을 비교하여 충돌 여부를 판단.
-> 색상 기반으로 쉽게 구현 가능하며, 색상 정보가 겹치는 경우 정확도가 떨어질 수 있다.

10. 메모리란 : 설명해 주시오.
ㄴ 라이트 (Ram휘발성) / 딥
-> 데이터를 저장하는 장치로서, 주 저장장치와 보조저장장치가 있다.
-> CPU와 레지스터 클러스터 관계?
-> 스트림? 코어클럭 분할
-> 쓰레드? -> 언리얼 시작창을 누르기만 해도 쓴거다.
※  프로그래머가 필요에 의해 데이터를 저장하는 공간으로써, 레지스터, 캐시 메모리, 주기억장치, 보조기억장치가 있습니다.
레지스터 -> 용량은 작고, 가격은 비싸지만 CPU에 직접 연결되어 있기 때문에 연산 속도가 기억 장치들에 비해 빠릅니다.
캐시메모리 -> 데이터를 미리 복사해두는 임시 저장공간을 의미합니다.
주기억장치 -> 대표적으로 RAM이 있습니다. 데이터를 읽거나 쓰는 것이 가능하며, 응용 프로그램, 운영체제 등을 불러와 CPU가
			 작업할 수 있도록 하는 기억장치입니다. 대신 휘발성 메모리로서 전원이 끊어지면 데이터가 전부 지워집니다.
보조기억장치 -> 대표적으로 HDD와 SSD가 있습니다.

OS에 대한 메모리 컨택스 (메모리 누수)에 대해 설명할 수 있음 Ok
※ 메모리 영역은 코드, 데이터, 힙, 스택으로 이루어져 있는데, 코드영역은 실행할 프로그램의 코드가 저장되는 영역.
데이터 영역 -> 전역 변수와 정적 변수가 저장되는 영역.
힙 영역 -> 메모리의 힙 영역은 사용자가 직접 관리할 수 있는 그리고 해야만 하는 메모리영역. 동적으로 할당되고 해제된다.
스택 영역 -> 메모리의 스택 영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역.
※ 여기서 동적으로 메모리를 사용했을 때 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상이 생길 수 있는데 이걸
메모리 누수라 합니다. 스택은 스택오버플로우가 발생하면 바로 에러를 알아차릴 수 있지만, 동적할당이 이루어지는 힙영역은
문제 없이 잘 작동할 수 있기 때문에 이런 누수 현상이 발생할 수 있습니다.
※ 가비지 컬렉션이란? -> 프로그램에서 더이상 사용하지 않는 메모리를 자동으로 정리하는 것입니다. 동적 할당 된 메모리영역
가운데 사용하지 않는 영역을 탐지해 자동으로 해지하여, 메모리 누수를 막을 수 있습니다. 하지만 C++에는 없는 기능입니다.
-> 방법으로는 트레이싱방식이 있습니다. 한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리로 간주하고,
그 밖의 메모리를 해제하는 방식을 가리킵니다. 트레이싱 방식중 하나가 마크 앤 스윕이며, 일부는 가비지 컬렉팅 기법으로
참조 카운팅 방식을 사용합니다. 마크 앤 스윕이란 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후
삭제하는 마크 앤 스윕 방법입니다. 객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지
아닌지를 표시(마크) 합니다. 그러고 나서 표시 되지 않은 객체를 삭제(스윕)하는 단계를 통해 메모리를 해제합니다.
※ 메모리 단편화
-> 메모리 단편화란 사용하기에 충분한 양의 메모리가 존재는 하지만, 사실상 사용이 불가능한 2가지 경우가 있습니다.
1. 내부 단편화 -> 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당 되어 공간낭비시 발생합니다.
해결방안 :
	1. 세그멘테이션 : 가변 길이 방식의 대표 유형
	2. 메모리 풀 : 동적 할당의 방식 중 하나. 미리 필요한 만큼 할당 받아서 만들어 둔다.
2. 외부 단편화 -> 메모리가 할당되고 해제되는 작업이 반복될 때, 중간에 생기는 작은 메모리 공간에서 발생.
합쳤을 때의 메모리 공간은 많지만, 각각의 메모리 공간의 사이즈는 작으므로 발생한다.
해결방안 :
	1. storage compaction(압축) : 주기적으로 삭제 공간을 회수하여, 메모리 공간들을 정리 비용이 많이 들어 자주쓸수없다. (주로 정해진 주기에 따라서 실행)
	2. CoaleScing(통합) : 단편화로 인해 쪼개진 공간들 중 인접한 공간들을 합쳐서 더 크게 만드는 방식.
	3. Placemanet Startege(배치 전략) : 배치를 잘하는 방식을 사용하여 단편화의 발생 가능성을 최대한 줄이는 방식
	4. Paging(페이징) 기법 : 고정 길이 방식의 대표 유형. (가상 메모리를 사용하여 논리공간 페이지와 물리공간 프레임)

★★★
11. 직원들이 퇴근하고 혼자 있을 때 문제점 발견 / 본인은 어떻게 할것인가? (심야 / 새벽)
ㄴ. 내가 책임질 수 있는 일이 아니라면, 상사에게, 팀장에게 보고를 하여 알리는게 우선이다.
※ 우선적으로 제가 책임질 수 있는 일이 아니라면, 직장 상사에게, 혹은 팀장님에게 현재 상황에 어떤 문제가 있는지 정확히 보고를
하여 알리는 것이 가장 좋다고 생각합니다.

12. 본인의 성향? (리더? / 부하? / 참모?)
ㄴ 참모가 제일 무난하다.
※  저의 성향으로는 단순히 상사의 지시에 따르며 하나만 하는 부하직원이 아닌, 상사의 지시에 1개를 알려주면 10가지를 배우며,
상황에 따라 어떠한 방법이 특정 상황에 가장 적합할지 고민하고 행동하기에 참모에 비슷하다고 생각합니다.

13. 자기보다 나이가 어린 사람 / 혹은 아주 많은 사람 아래에서 일 할 수 있나?
ㄴ + 텃세 / 부당 상황.
※  저는 일 할 수 있다고 생각합니다. 왜냐하면 저는 일하는것에 있어 나이는 숫자에 불과하다고 생각하기 때문에
저보다 일을 잘한다면 당연히 저의 선배가 될 수 있다고 생각합니다. 그리고 텃세와 부당상황에 대해서는 개인적으로 해결할 수 있는
문제가 아니라면, 상사 혹은 팀장님께 도움을 요청하여 해결하도록 노력할 것 입니다.

★★★
14. 구조체 / 클래스 차이점?
ㄴ C++ 하고 C#을 나눠서 얘기하면 가산점. (언리얼을 썼기 때문에)
※  구조체와 클래스는 C++ 과 C#에서 모두 사용되며, 두 언어에서의 특성과 차이점이 있습니다.
먼저 C++ 에서는 기본 접근 제어 지시자가 구조체에서는 public, 클래스에서는 private 입니다.
그리고 구조체는 보통 값 타입으로 사용되고, 클래스는 참조 타입으로 사용 됩니다.
C#에서는 접근제어 지시자가 기본적으로 둘다 private 입니다.
-> 심화? 구조체는 값 타입으로 동작하며, 기본적으로 스택에 할당됩니다. 클래스는 참조 타입으로 동작하며, 힙에 할당됩니다.
구조체는 상속을 지원하지 않으며, 소멸자를 정의할 수 없습니다. 클래스는 상속과 소멸자를 지원한다.

15. LifeCycle 설명? (전 / 지 / 동) / 동작 방식?
ㄴ 전역변수, 지역변수, 동적할당.
-> Allocate -> Release -> Memory Pool + {}
ㄴ 변수의 메모리가 확보된 (Allocate) 시점부터 해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점
ㄴ 기본적으로 변수는 자신이 선언된 Scope 내에서 생성되고 소멸이 된다.
ㄴ 일반적으로 전역 -> 어플리케이션의 주기 / 지역 -> 함수의 주기
※  변수의 LifeCycle(생명주기)는 변수의 생성, 사용, 소멸 과정에 따라 다릅니다. 변수의 메모리가 확보된 (Allocate) 시점부터
해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점입니다. 기본적으로 변수는 자신이 선언된 Scope 내에서
생성되고 소멸 됩니다.

ex) {}

for(size_t i = 0; i < length; i++)
{
	if()
	{
		/// 주석 내용~ {} 알려줄때는 / 3개쓰기
		{

		}
	}
}

16. 현재 읽고 있는 전공책.
 ㄴ 모던 시리즈(생각 잘하고 말하도록.) 드래곤, 스컬, 물, 노을, 공룡
※  현재 읽고 있는 책으로는 다이렉트는 드래곤 혹은 물방울 책을 참고하고 있고, CS 지식으로는 공룡책을 참고하여 공부하고있습니다.


17. A* 알고리즘 알고 있는지? 알고 있다면 동기화 기법? (2D 에서 쓸일이 많다.)
ㄴ 다익스트라 원리 채용한 알고리즘
 ㄴ 현재까지 가장 최소의 비용으로 도달한 지점부터 탐색한다.
ㄴ f(x) = g(x) + h(x)
 ㄴ 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색.
ㄴ g(x) : 현재 상태 비용
ㄴ h(x) : 현재에서 다음 휴리스틱
장점 : 쉽다. 이해하기 편하다. 자료구조를 안탄다. (어느것이든 돼서)
단점 : 느리다. 최적화를 해야 한다.
동기화 기법 : 구역을 나눠서 연산하는 방법, JPS(가지치기, 점프, 리서치) 등 다양한 기법이 있다.
개선안 : JPS(가지치기, 점프, 리서치) A* 의 개선판. 훨씬 빠름. (단점 : 중간중간이나, 듬성듬성 오브젝트가 많으면, 프로그램이 뻑 날 수 이씀)
※  A* 알고리즘이란 -> 그래프 탐색 알고리즘 중 하나로,
자신의 주변 노드를 탐색하여 갈 수 있는지 확인하고, 목표지점까지의 비용을 계산하여, 최소가 되는, 즉 최단 경로를 찾기 위해 사용되는 알고리즘입니다.
특히 2D 경로 탐색에서 주로 사용되며, 다익스트라 알고리즘과 최적 우선탐색의 조합으로 목표에 도달하는 비용을 예측하고 효율적으로
경로를 찾습니다. 공식으로는 현재상태비용, 현재에서 다음휴리스틱, 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색하는 것입니다.
개선안으로는 구역을 나눠서 연산하는 방법(다중 레벨 경로 탐색)과 JPS가 있습니다.

구역 나눠서 연산
※ 맵을 여러 구역으로 나누어 구역 간의 경로 정보를 미리 계산하여 큰 범위에서의 탐색을 줄임으로써 성능을 개선하는 방식입니다.
동작방식
1.맵 구분: 구역을 나눠서 연산하는 방법은 전체 맵을 여러 개의 작은 구역으로 나누고 구역들은 일종의 추상화된 노드라고 생각 하여
작은 구역들의 경계에서 이동 가능한 포탈 노드를 정의할 수 있습니다.
2.고수준 경로 탐색: 최단 경로를 구할 때 먼저 구역 간의 큰 그림에서 경로를 탐색합니다. 이때 구역 자체를 노드로 보고 경로를 찾습니다.
3.저수준 경로 탐색: 고수준에서 찾은 경로를 기준으로 세부적으로 각 구역 내부에서 최단 경로를 탐색합니다.

JPS(Jump Point Search)
※  불필요한 노드확장을 생략하고, 탐색할 필요가 없는 경로를 빠르게 건너뛰도록 최적화한 알고리즘입니다. A* 알고리즘은 모든 인접노드를
탐색하며 확장해 나가지만, JPS는 그리드에서 특정 점프포인트들만 탐색합니다. 즉, 불필요한 노드 확장을 피하고, 경로의 핵심적인
전환점들만 찾아 나가는 방식입니다.
동작방식
1.일반화된 이동: JPS는 처음부터 모든 방향으로 최대한 멀리 이동합니다. 그리드 상에서 상하좌우 및 대각성 방향으로 최대한 멀리 이동 후
특정 조건에 따라 탐색을 중단하거나 계속 확장합니다.
그리드란? (행과 열로 이루어진 사각형, 즉 격자형태로 이루어진 구조를 말하며, 2D경로 탐색이나 시뮬레이션에 자주 사용됩니다.)
2.중간 노드 생략: 경로 상에 중요하지 않은 중간 노드들은 건너뛰고, 경로의 전환점이나 중요한 포인트(점프)에만 도달할 때까지 이동합니다.
점프포인트는 경로가 꺽이거나 회전해야 하는 중요한 지점. JPS는 이 점프 포인트만 탐색 대상으로 사용
3.휴리스틱 사용: A* 알고리즘의 공식을 사용하지만, 확장할 때 불필요한 중간 노드를 배제하여 성능을 높입니다.

블랙 A* (블록A*)
※  그리드의 작은 섹션에 있는 모든 가능한 경로를 포함하는 로컬 거리 데이터베이스를 생성합니다.
이 데이터베이스를 참조하여 조각별 임의 각도 경로를 빠르게 찾습니다.
모든 각도 경로 계획 알고리즘은 경로의 회전이 모든 각도를 가질 수 있도록 하면서 그리드 맵의 두 지점 사이의 유클리드 최단경로를
검색하는 경로찾기 알고리즘입니다. 그로 인해 열린 공간을 직접 통과하고 상대적으로 회전이 적은 경로가 생성 됩니다.
https://en.wikipedia.org/wiki/Any-angle_path_planning#A*-based

★★★
18. 포트폴리오를 제작하면서 다른 사람들부터 이런점은 내가 더 낫다? 혹은 어필하고 싶은 기능
ㄴ 무기를 만들때 추상 클래스를 활용하여 ~ 추가할 때 좀 더 용이하게 만들었다 등
※ 제 포트폴리오를 통해서 남들보다 더 낫다고 생각하는 것은, 추상 클래스를 활용하여, 확장성과 유지보수성을 높인 설계에 있습니다.
예를 들어, 여러 개의 비슷한 기능을 가진 스킬들을 관리하는 시스템에서, 공통된 인터페이스와 기본 동작을 추상 클래스에 정의해두면,
새로운 스킬을 추가할 때마다 전체 코드를 수정할 필요 없이 새로운 클래스에서 필요한 부분만 구현하면 되어 재사용성을 극대화하고
중복된 코드를 줄여주며, 유지보수에 좋게 설계했다고 생각합니다.


// 9 / 13
19. A* 2D / A* 3D 차이점에 대해 알고 있는지?
-> 2D는 현재 보여지는 영역(카메라가 보는)모든 영역을 검사.
-> 3D에서는 마우스로 입력 받을때 확인해야되는데, 캐릭터 반경에 원을 만들어두고, 반경까지만 검사. (처음에 벽을 찍어도 일단은 가는 이유)
   EQS?, 다익스트라.

※ 2D 에서는 X,Y 좌표를 사용하여, 4방향 또는 8방향으로 이동하며 현재 2차원 평면에서 보여지는 모든 영역을 검사하고,
거리계산으로는 2D는 멘해튼거리(상하좌우), 유클리드거리(대각선)로 계산, 3D는 체비셰프 거리(모든 방향)까지 계산합니다.
3D에서는 Voxel과 Navigation Mesh를 알고있는데, Voxel이란 Volume + Pixel의 합성어로 부피를 가진 픽셀이란 뜻을 가집니다.
3D 공간을 같은 크기의 정육면체로 나눈 단위라고 할 수 있습니다. 길찾기 원리로는 A* 알고리즘의 Start지점부터, End지점까지의
탐색 공간이 격자화 되어 그래프를 구성하게 되면 적용이 가능한데, Voxel로 공간을 분할하게 되면 2D와 마찬가지로 3D공간에서도
A*알고리즘을 적용할 수 있습니다. 특정 Voxel과 인접한 8개의 아웃 복셀들에 대해 A* 알고리즘에 필요한 상태값과 휴리스틱 값을
계산하면서 최단 경로를 검색하게 됩니다.
Navigation Mesh는 바닥, 장애물과 같은 게임월드의 정보를 미리 저장해두고, 이동할 때 저장된 정보를 바탕으로 장애물을 피해
목표 위치까지 이동하는 경로 탐색을 제공하는 것입니다.

EQS란 (Environment Query System)
 인공지능 분야에서 사용되는 시스템으로, 환경 정보를 기반으로 AI 캐릭터가 결정을 내리는데 도움을 주는 툴이며, 언리얼에서 주로
 사용 됩니다.
 AI 엔티티가 주변환경이나 레벨을 쿼리하여 사용 가능한 데이터를 얻게 해줍니다. EQS 쿼리를 사용하면 AI 캐릭터에게 플레이어를
 플레이어를 공격할 최적의 위치를 찾거나, 가장 가까운 회복 아이템을 찾도록 지시를 내릴 수 있습니다. 따라서 AI 엔티티의 주변을
 파악해야 하는 중요한 의사 결정에서 매우 유용합니다.
 1. 쿼리 -> 환경에서 특정 조건을 만족하는 객체나 위치를 찾는다.
 2. 필터링 -> AI가 필요로 하는 정보를 찾기 위해 여러 가지 필터를 적용할 수 있다.
 3. 컨텍스트 기반 -> AI가 현재 처한 상황을 반영해 적응형으로 행동할 수 있도록 환경 데이터를 제공한다.

다익스트라 알고리즘이란
-> 가중치가 있는 그래프에서 최단 경로를 찾기 위한 알고리즘입니다. A* 알고리즘과의 차이로는 휴리스틱 함수를 사용하지 않으며,
모든 경로를 동일하게 고려하여 최단경로를 찾습니다. 탐색 방식으로는 우선순위 큐를 사용하여 탐색하며 모든 노드의 최단 거리를 계산합니다.

20. STL 정의?
ㄴ 자료구조, 알고리즘을 템플릿화 시켜놓은 라이브러리.
※  표준 템플릿 라이브러리로,일반화된 다양한 자료구조와 알고리즘을 제공하는 것 입니다.
주로 컨테이너 (vector, list, deque, set, map 등이 있습니다.),
반복자(컨테이너 요소에 접근하고 순회, 반복자는 포인터처럼 작동하며, 요소들에 차례로 접근할 수 있게 해줌),
알고리즘(정렬, 탐색, 복사 등의 작업을 수행하는 함수)이 있습니다.

21. 본인의 코딩 스타일은 어떤가?
ㄴ 프로토타입을 먼저 작성한다.
※ 제 코딩 스타일은 객체지향적 프로그래밍을 중요시하여, 코드를 캡슐화 하여 데이터를 보호하고, 재사용하기 위해 상속,
다양한 상황에서 유연하게 동작하기 위해 다형성, 그리고 복잡한 로직을 단순화하고, 코드의 가독성을 높이기 위해 추상화를 적용하여
유지보수성이 뛰어난 코드를 작성하기 위해 노력합니다.

22. 참고하는 사이트?
ㄴ 마이크로 소프트 도큐먼트, C++ 레퍼런스, C++ 스택오버플로우
※ 제가 참고하는 사이트로는 마이크로 소프트 도큐먼트, C++ 레퍼런스가 있습니다.

언리얼에 들어간 DirectX의 개념은 공부를 했다.

23. 디자인 패턴에 대해 아는가?
ㄴ 프로그래머들이 개발하면서 발생하는 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안
※ 프로그래머들이 개발하면서 발생한 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안을 디자인 패턴이라고 합니다.

24. 알고있는 디자인 패턴? / 혹은 사용해야할 예시를 들어보시오. (GOF)
ㄴ 6 ~ 8개 알고있으면 좋은데, 포폴에서 쓴 디자인 패턴을 얘기하는게 가장 좋다.
컨택스트, 커맨드
싱글톤? 얘기를 할때 엄한거 얘기하지 말고, 언리얼 추상팩토리에 대해 얘기하는게 더 좋다.
※
1. 싱글톤
-> 특정 클래스의 인스턴스가 딱 하나만 존재하도록 보장하는 패턴이며, 전역 접근 가능하고, 필요할 때 최초로 인스턴스가 생성됩니다.
언리얼에서는 주로 게임 상태나 설정, 글로벌한 매니저 클래스 등을
하나의 인스턴스로 관리하려 할 때 종종 사용 되는 것으로 알고있습니다.
사용하는 이유
-> 한번도 사용하지 않는다면 아예 인스턴스를 생성하지 않습니다.(즉 초기화 되지 않습니다.)
-> 런타임에 초기화 됩니다. 컴파일러는 main 함수를 호출하기 전에 정적 변수를 초기화하기 때문에 프로그램이 실행된 다음에야 알 수
있는 정보를 활용할 수 없습니다. 하지만 싱글턴은 최대한 늦게 초기화 되기 때문에 클래스가 필요로 하는 정보는 준비가 되어 있습니다.
-> 싱글턴을 상속할 수 있습니다. -> 파일 시스템 래퍼가 크로스 플랫폼을 지원해야 한다면 추상 인터페이스를 만든 뒤, 플랫폼마다
구체 클래스를 만들면 됩니다.
단점 -> 클래스 사이의 의존성이 높아진다. (결합도가 낮아야 사용할 수 있습니다.)
-> 알고보니 전역 변수, 전역변수는 코드를 이해하기 어렵게 하며, 전역 변수는 커플링을 조장할 수 있고, 멀티스레딩 같은 동시성
프로그래밍에 알맞지 않습니다.

2. 상태 패턴
-> 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼
보입니다. 즉, 조건문이 아니라 객체의 상태를 별도의 클래스로 캡슐화하며, 객체는 Runtime에 자신의 행동을 변경합니다.
그래서 FSM(유한 상태 기계)를 언급할 수 있습니다.
FSM이란 -> 가질 수 있는 상태가 한정된다. 한 번에 한가지 상태만 될 수 있다. 입력이나 이벤트가 기계에 전달된다.
각 상태에는 입력에 따른 다음 상태로 바뀌는 전이가 있다.
단점 -> 상태 기계는 제한된 구조를 강제함으로써 복잡하게 얽힌 코드를 정리할 수 있게 해주지만, 하드코딩되어 있는 전이만이 존재합니다.
더 복잡한 곳에 적용하다 보면 한계에 부딪히는데 이를 위한 해결 방안으로 병형 상태 기계가 있습니다.
즉, 두 종류의 사태, 무엇을 하는가와 무엇을 들고 있는가를 두 개로 나누면 됩니다.

3. 관찰자 패턴 (Observer Pattern)
-> 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지
받고 자동으로 업데이트 될 수 있게 만듭니다.
단점 -> 등록한 관찰자를 삭제할 때 일련의 처리를 하지 않으면 불필요한 퍼포먼스 낭비가 일어날 가능성이 있습니다.

4. 명령 패턴(Command Pattern)
-> 요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기 시키거나 로깅하며, 되돌릴
수 있는 연산을 지원합니다. 따라서 요청 코드와, 수행 코드사이의 의존성을 줄이며, 입력 처리를 유연하게 관리하여
명령을 추가하거나 재사용이 쉬워집니다.

5. 컴포넌트 패턴 (Component Pattern)
-> 한 객체가 여러 분야를 서로 커플링 없이 다룰 수 있게 하는 것입니다. 부품을 조합하여, 복잡한 동작을 구현할 수 있고
게임 캐릭터를 레고 조립하듯이 구성하는 것입니다. 개별 컴포넌트를 재사용하여 개발시간을 줄이고, 유지보수를 쉽게 만듭니다.
-> 사용때 : 한클래스에서 여러 분야를 건드리고 있어서, 이들을 서로 디커플링하고 싶다, 클래스가 거대해져서 작업하기가 어렵다.
여러 다른 기능을 공유하는 다양한 객체를 정의하고 싶다. 단 상속으로는 딱 원하는 부분만 골라서 재사용할 수 가 없다.

6. 빌더 패턴 (Builder Pattern)
-> 복잡한 객체의 생성 과정을 단계별로 분리, 객체의 생성과 표현을 분리하는 것입니다. 생성하는 과정에서 서로 다른 표현을 가진
객체를 만드는 것이며 복잡한 게임 오브젝트나 레벨을 생성할 때 사용 됩니다.

7. 플라이웨이트 패턴 (Flyweight Pattern)
-> 메모리 사용은 최적화하기 위한 패턴이며, 객체의 공유를 촉진하는 형태입니다.
플라이 웨이트 패턴 상태 종류-> 변경 불가능한 공유상태, 객체마다 다를 수 있는 개별 상태가 있습니다.
공유상태는 객체 내부에 저장, 개별 상태는 클라이언트에 의해 관리됩니다. -> 대규모 게임 환경에서 반복되는 아이템을 관리할 때나,
모바일 게임에서도 유용합니다.

24 - 2 템플릿?

25. C / C++ 의 차이점?
ㄴ 객체냐 절차냐는 너무 라이트, 메모리에 대해서 얘기해야됨. 복사, 참조.
※ 우선 절차지향과 객체지향으로 나눌 수 있지만, 참조와 포인터 변수, Malloc과 New의 차이점을 말씀드릴 수 있습니다.
 우선 참조부터 말씀드리자면, C언어에는 참조자라는 개념이 없어, 주로 값 전달과 포인터를 사용하여 복사와 참조의 역할을 수행합니다.
C++에서는 참조자라는 개념이 도입되어, 더 직관적이고 안전한 방식으로 사용됩니다. 참조자란 실체가 있어야 하며, 즉시 할당되어야합니다.
즉 Null, Nullptr로 할당이 불가능합니다. 참조자는 초기화 리스트를 사용하여 먼저 초기화 해야하는데, 이는 생성자 내부에서의
초기화는 먼저 Null로 생성한 뒤 값을 넣는 방식이기 때문이며, 한 번 할당하면 다른 곳에 재할당 불가능합니다.
따라서 복사와 참조의 성능 차이로, 값에 의한 전달은 복사본을 생성하므로, 큰 객체를 전달할 때는 성능 문제가 발생할 수 있지만
참조에 의한 전달은 데이터를 복사하지 않고, 원본을 직접 참조하므로, 큰 데이터를 전달할 때 메모리 효율성이 높아집니다.
 다음으로, Malloc 과 New의 차이점으로는 Malloc은 단순한 메모리 할당이며 할당시 메모리의 사이즈를 입력해서 할당 받습니다.
Malloc은 Void*를 리턴하기 때문에 원하는 타입으로 캐스팅해서 사용 가능합니다.
New는 할당과 동시에 초기화 가능하며 초기값을 줄 수 있습니다. 생성자가 호출 됐을때, 오버로딩도 가능하며 할당시 객체의 크기를
입력하여 할당 받습니다.
1. new는 C++에서 제공하는 키워드 이지만 <-> malloc은 라이브러리 제공함수 입니다.
2. new는 할당할 타입을 지정하고, 해당 타입의 포인터를 Return 하지만,
   malloc은 필요한 메모리 양을 바이트 단위로 지정하고 void*로 Return 합니다.
3. new는 다른 연산자의 도움이 필요하지 않습니다 <-> malloc의 경우 sizeof 연산자와 cast의 도움이 필요합니다.
4. new는 메모리를 할당과 동시에 초기값을 줄 수 있습니다. <-> malloc은 메모리를 할당하는 것이 목적이기에 초기값을 줄 수 없습니다.
5. new는 재할당이 불가능하며, 새로운 변수를 만들어 대체할 땐 주소가 변경됩니다.
   malloc은 객체가 아니며 빈번하게 재할당할 경우 사용합니다.
6. new를 통한 할당은 delete로 해제해야 하며, 동적 메모리 할당을 해제하며 소멸자를 호출합니다.
   malloc을 통한 할당은 free로 해제해야 하며, 동적 메모리할당을 해제합니다.

- 이 질문은 어렵다..
26. C++ 왜 공부하는가? / 굳이 왜 C++?
ㄴ 내 스타일대로 설명할줄 알아야 할 것 같음.
들어가야할 것(메모리를 직접 관리 할 수 있다. -> 최적화 할 수 있는 것. 컴퓨터의 Low Level로 들어가 구조를 설명 할 줄 아는 것.)
Managed언어, UnManaged언어의 차이를 얘기할 수 도 있겠다.
※ 제가 C++을 공부하는 이유는 프로그래밍 언어 중에서도 고성능, 저수준 메모리 관리, 그리고 하드웨어와 밀접하게 연결된 개발을 할 수
있는 강력한 언어라고 생각해서 입니다. 게임에서는 단 1초가 아닌 밀리세컨드 단위로도 중요한 공간이기 때문에 이러한 성능과 제어가
중요한 프로그램을 개발하는데 최적화 된 언어는 C++이기 때문입니다.
 관리형 언어와 비관리형 언어의 차이를 들 수 있는데 C#과 자바는 가비지 컬렉션과 같은 자동 메모리 관리 기능을 사용하여 메모리 해제에
신경 쓰지 않도록 하지만 실시간 응답이 필요한 경우엔 성능이 떨어질 수 있습니다. 반면에 C++은 프로그래머의 역량에 따라 
메모리를 효율적으로 관리하여 성능을 최적화하고, 실시간 성능이 중요한 시스템에 적합합니다.
또 하드웨어와 가까운 레벨에서 프로그래밍할 수 있기 때문에 컴퓨터의 메모리 구조와 처리 과정을 이해하고 이를 최적화 하는데 유리합니다.
그렇기에 그래픽 엔진 개발에도 적합하다고 생각합니다.

27. 본인이 작업한 결과물중에 어떤걸 중점적으로 붙들고 공부해 보았는가?
ㄴ 포폴 -> 알고리즘이나 패턴, 설계가 들어가는게 좋다. AI / 캐릭터 / Anim 도 예를 들 수 있음.

28. 희망 연봉?
ㄴ IT쪽은 상향해서 부르는게 좋다. 회사 내규에 따라서 주겠다 하면 -> 저는 그래도 3500~4000정도를 받았으면 좋겠습니다.
희망연봉 얘기하기.

29. 동료랑 의사 차이날때 어떻게 처리했는가?
ㄴ 사례 + 결국 내가 잘했다~ 중재를 했다~

30. 상속의 장점에 대해?
ㄴ 
추상 객체가 들어있다는 전제하에 얘기를 하는 것.

31. 다중 상속은 왜 조심해야 하는가?
ㄴ 다이아몬드 구조 -> 모호성 -> 인클루드가 깨져서 -> 상호참조가 발생한다.

32. 지원자가 생각하는 랜더링 엔진은 무엇일까요?
ㄴ DX관한 질문임. 랜더링 파이프라인 -> 파이프라인을 공정해서 쓸 수 있냐?
-> 파이프라인을 커스텀 할 수 있는 라이브러리와 툴이 붙어있는 것이 엔진입니다. -> 이후 랜더링 파이프라인에 대해 언급.

33. MVC 패턴에 대해 알고 있는가?
ㄴ Model / View / Controller
ㄴ 프로젝트를 구성할 때 그 구성요소들 (세가지로 나눈 패턴)
사용할때는 Controller -> Model -> View
Controller -> 입력 발생 (서비스)
Model -> 입력에 대한 처리 발생
View -> 보여지는 것.
