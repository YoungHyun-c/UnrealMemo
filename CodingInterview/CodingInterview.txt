============================================================

- 매일 매일 회사 가기전까지 하루에 최소 2시간 이상씩 투자할 것.
 ㄴ 틈틈이 확인할 것.

 01. 코딩 테스트 준비.
  ㄴ 과정 끝날쯤까지 목표는 2단계 후반 / 골드
  ㄴ 프로그래머스 
  ㄴ 백준
 02. 칸 아카데미 : https://ko.khanacademy.org/
  고1 수학 목표.
 03. 영어공부 : https://hanmadiro.com/
  독해 공부


언어 50%
자료구조 알고리즘 30퍼
선형, 수학 요소 20퍼

============================================================

- 코딩 인터뷰

00. 자기 소개?
ㄴ 1분.
-> 장 단점은 얘기하는 것은 별로.
-> 단점은 중화시키고, 중위적으로 표현할 것.
-> 프로그래머적으로 엮어서 소개해야 공감, 스토리 라인 형성.

01. 입사 동기?
ㄴ 왜 널 뽑아야 하나? 어필?
-> 성장 이력. 개념적으로 지식을 갖고, 넓게 생각한다는걸 이력해야 한다.

02. 야근 여부와 의지에 대해
-> 회사의 사정과 배워야 할께 많기 때문에 회사의 사정에 맞춰 충분히 가능함을 어필.

03. 성격의 장 / 단점?
장점 -> 원활한 협업 관계, 소통을 어필.
단점 -> 중위적으로 푼다.

04. 외국어 할 줄 아는가? (중 / 대)
ㄴ 프로그램 얘기가 무조건 나와야 한다.
-> 제가 외국어를 말하기 수준은 어려울 수 있으나, 업무 상으로 필요한 독해력은 가능하다고 생각한다 어필.

05. 절차지향과 객체지향의 차이점에 대해 설명해 보시오.
ㄴ 

06. 객체지향 4대 특징?
ㄴ
1. 캡슐화
2. 상속성
3. 다형성
4. 추상화

07. 객체지향 5대 설계 원칙에 대해 설명해 보시오.
ㄴ
SRP -> 
OCP ->
LSP ->
ISP ->
DIP ->

08. 프레임워크와 라이브러리 차이점에 대해 알고 있는지?
ㄴ 1. 미주알 고주알..... 2. 엔진 팔이  3. 아무말 대잔치
ㄴ 제어 (IOC : 제어의 역전)
사용자에 의해 제어를 맡기냐, 라이브러리에 제어를 맡기냐 차이.

09. 메가맨 해봤는지? 해봤다면 이와 비슷한 장르의 충돌처리는 어떻게 할건지 본인의 의견 제시.
ㄴ 픽셀 충돌.

10. 메모리란 : 설명해 주시오.
ㄴ 라이트 (Ram휘발성) / 딥
-> 데이터를 저장하는 장치로서, 주 저장장치와 보조저장장치가 있다.
-> CPU와 레지스터 클러스터 관계?
-> 스트림? 코어클럭 분할
-> 쓰레드? -> 언리얼 시작창을 누르기만 해도 쓴거다.

★★★
11. 직원들이 퇴근하고 혼자 있을 때 문제점 발견 / 본인은 어떻게 할것인가? (심야 / 새벽)
ㄴ. 내가 책임질 수 있는 일이 아니라면, 상사에게, 팀장에게 보고를 하여 알리는게 우선이다.

12. 본인의 성향? (리더? / 부하? / 참모?)
ㄴ 참모가 제일 무난하다.

13. 자기보다 나이가 어린 사람 / 혹은 아주 많은 사람 아래에서 일 할 수 있나?
ㄴ + 텃세 / 부당 상황.

★★★
14. 구조체 / 클래스 차이점?
ㄴ C++ 하고 C#을 나눠서 얘기하면 가산점. (언리얼을 썼기 때문에)
-> 

15. LifeCycle 설명? (전 / 지 / 동) / 동작 방식?
ㄴ 전역변수, 지역변수, 동적할당.
-> Allocate -> Release -> Memory Pool + {}
ㄴ 변수의 메모리가 확보된 (Allocate) 시점부터 해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점
ㄴ 기본적으로 변수는 자신이 선언된 Scope 내에서 생성되고 소멸이 된다.
ㄴ 일반적으로 전역 -> 어플리케이션의 주기 / 지역 -> 함수의 주기

ex) {}

for(size_t i = 0; i < length; i++)
{
	if()
	{
		/// 주석 내용~ {} 알려줄때는 / 3개쓰기
		{

		}
	}
}

16. 현재 읽고 있는 전공책.
 ㄴ 모던 시리즈(생각 잘하고 말하도록.) 드래곤, 스컬, 물, 노을, 공룡


17. A* 알고리즘 알고 있는지? 알고 있다면 동기화 기법? (2D 에서 쓸일이 많다.)
ㄴ 다익스트라 원리 채용한 알고리즘
 ㄴ 현재까지 가장 최소의 비용으로 도달한 지점부터 탐색한다.
ㄴ f(x) = g(x) + h(x)
 ㄴ 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색.
ㄴ g(x) : 현재 상태 비용
ㄴ h(x) : 현재에서 다음 휴리스틱
장점 : 쉽다. 이해하기 편하다. 자료구조를 안탄다. (어느것이든 돼서)
단점 : 느리다. 최적화를 해야 한다.
동기화 기법 : 구역을 나눠서 연산하는 방법, JPS(가지치기, 점프, 리서치) 등 다양한 기법이 있다.
개선안 : JPS(가지치기, 점프, 리서치) A* 의 개선판. 훨씬 빠름. (단점 : 중간중간이나, 듬성듬성 오브젝트가 많으면, 프로그램이 뻑 날 수 이씀)

18. 포트폴리오를 제작하면서 다른 사람들부터 이런점은 내가 더 낫다? 혹은 어필하고 싶은 기능
ㄴ 무기를 만들때 추상 클래스를 활용하여 ~ 추가할 때 좀 더 용이하게 만들었다 등