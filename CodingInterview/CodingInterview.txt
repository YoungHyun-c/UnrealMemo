============================================================

- 매일 매일 회사 가기전까지 하루에 최소 2시간 이상씩 투자할 것.
 ㄴ 틈틈이 확인할 것.

 01. 코딩 테스트 준비.
  ㄴ 과정 끝날쯤까지 목표는 2단계 후반 / 골드
  ㄴ 프로그래머스 
  ㄴ 백준
 02. 칸 아카데미 : https://ko.khanacademy.org/
  고1 수학 목표.
 03. 영어공부 : https://hanmadiro.com/
  독해 공부


언어 50%
자료구조 알고리즘 30퍼
선형, 수학 요소 20퍼

질문에 대한 답을 못할시 답 못한 문제 30초 ~ 1분 발표.

============================================================

- 코딩 인터뷰

00. 자기 소개?
ㄴ 1분.
-> 장 단점은 얘기하는 것은 별로.
-> 단점은 중화시키고, 중위적으로 표현할 것.
-> 프로그래머적으로 엮어서 소개해야 공감, 스토리 라인 형성.
※ 안녕하세요. 저는 OO회사에 지원하게 된 홍영현 입니다. 저는 이전 회사에서 가스탱크, 지하 수로, 터널 등 다양한 장소로 출장을 다니면서,
현재 우리가 살고 있는 세상을 데이터화하는 작업이 얼마나 중요한지 알게 되었습니다. 다양한 시설물에 센서를 부착해 데이터를 수집하고,
이를 3D 평면화하거나 가상공간에서 관리하는 경험을 했었습니다. 이 과정에서 현실을 가상 세계로 옮겨와 관리하고 분석하는 기술의
발전에 깊은 관심을 갖게 되었고, 이를 구현하는데 가장 적합한 방법이 객체지향 프로그래밍이라는 것을 깨달았습니다.
이러한 경험을 바탕으로 저는 게임프로그래밍을 통해 현실 세계와 가상세계를 연결하고, 더욱 복잡하고 정교한 시스템을 구현하는 일을 하고 싶다는
열망을 갖게 되었습니다. OO 회사가 제공하는 혁신적인 게임 개발 환경과, 다양한 시도가 이 회사의 장점이라고 생각하여 지원하게 되었고,
더욱 발전 시키고 싶습니다.

01. 입사 동기?
ㄴ 왜 널 뽑아야 하나? 어필?
성장 이력. 개념적으로 지식을 갖고, 넓게 생각한다는걸 이력해야 한다.
※ 저는 다양한 경험을 통해서 성장을 해왔으며, 코딩을 배울 때 나무를 보는 것이 아닌 숲을 보라는 말을 들었습니다. 그 말은 즉슨
 문제를 해결할 때 우선적으로 부딪혀 보는 것이 아닌 넓고 유연한 사고를 바탕으로 접근하는 것이 중요하다는 것을 배웠습니다.
  그리고 제가 책을 읽고 감명깊었던 글귀가 있었는데, 어린왕자 책에서, '큰 배를 만들고 싶으면 연장을 주고 배 만드는 법을
 가르치기 전에 먼저 바다에 대한 동경을 심어주면 그 사람 스스로 배를 만드는 법을 찾아낼 것이다' 라는 말이 정말 마음에 들었습니다.
 코딩을 통해 단순히 게임 만드는 것을 배운 것이 아닌 제가 동경하는 게임을 만듬으로써 저는 팀을 위해 가독성 및 재사용성이 좋은 코딩을
 만들기 위해 노력해 왔음으로 저를 뽑아주시면 이 회사에 큰 기여가 될 것이라고 생각합니다.


02. 야근 여부와 의지에 대해
회사의 사정과 배워야 할께 많기 때문에 회사의 사정에 맞춰 충분히 가능함을 어필.
※ 회사의 상황과 프로젝트 진행에 맞춰 필요한 경우에는 야근도 충분히 가능합니다. 현재 제가 회사내의 규정 및 시스템 등 배워야 할 부분도 많기
 때문에 추가적인 시간이 필요하다면 그에 맞춰 유연하게 대응할 준비가 되어 있습니다. 회사의 목표 달성과 제 개인적인 성장 모두 중요하다고
 생각하기 때문에, 회사의 일정에 맞춰 최선을 다하겠습니다.

03. 성격의 장 / 단점?
장점 -> 원활한 협업 관계, 소통을 어필.
단점 -> 중위적으로 푼다.
※  혹시 카피바라라는 동물에 대해서 알고계신가요? 카피바라는 다양한 동물들과의 친화력을 갖고있는 것으로 잘 알려져 있습니다.
카피바라가 다양한 동물들과 잘 어울리며 평화롭게 지내는 것 처럼, 저는 팀 내에서 다양한 사람들과 원활하게 소통하며 협업하는 것을
중요하게 생각합니다. 서로의 강점을 인정하고 존중하며 조화를 이루는 환경에서 최고의 성과를 낼 수 있다고 믿고있습니다.
이처럼 저는 긍정적인 소통과 협업을 통해 팀의 목표를 함께 달성할 수 있는 능력이 저의 큰 장점이라고 생각합니다.
 그래서 단점으로는 협업을 중요하게 생각하다 보니, 모든 의견을 충분히 고려하는 과정에서 결정을 내리는데 시간이 걸릴 수 있습니다.
하지만 이를 통해 다양한 관점을 포용하고, 더 나은 결정을 내릴 수 있다고 생각합니다. 그래서 저는 빠른 의사결정이 필요할 때는
우선순위를 정해 효율성을 높이도록 노력하고 있습니다.

04. 외국어 할 줄 아는가? (중 / 대)
ㄴ 프로그램 얘기가 무조건 나와야 한다.
-> 제가 외국어를 말하기 수준은 어려울 수 있으나, 업무 상으로 필요한 독해력은 가능하다고 생각한다 어필.
※  제가 외국어를 원어민과 대화할 정도의 수준으로 말하기는 어려우나, 업무 상으로 필요한 코딩 스탠다드나, C++ Reference 사이트를 참고하여, 남들에게
설명할정도의 독해력을 가지고 있습니다.

05. 절차지향과 객체지향의 차이점에 대해 설명해 보시오.
※  절차지향 프로그래밍이란 순차적인 명령을 기반으로 프로그램이 실행되며, 데이터와 함수는 별도로 취급됩니다. 대표적인 언어로는
C언어가 있습니다.
※  객체지향 프로그래밍이란 프로그램을 객체라는 단위로 나누어 개발하는 것 입니다. 객체는 데이터(속성)와 그 데이터를 처리하는
매서드(함수)를 함께 묶어 관리합니다. 프로그램이 동작할 때 객체들이 서로 상호작용하며 문제를 해결해 나갑니다. 하지만 캡슐화와
격리구조로 인해 절차지향 프로그래밍에 비해 상대적으로 속도가 느립니다. 또한, 객체로 사용하기 때문에 추가적인 포인터 크기의
메모리와 연산에 대한 비용이 듭니다.

06. 객체지향 4대 특징?
ㄴ
1. 캡슐화
※  서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호 하는 것을 캡슐화라고 합니다.

2. 상속성
※  기존의 클래스를 재활용하여, 새로운 클래스를 만들어 사용하는 것이며, 이는 OOP 특징인 캡슐화를 보존하며 사용할 수 있습니다.

3. 다형성
※  상속받은 매서드나 클래스가 서로 다른 클래스에서 다양한 방식으로 동작하게 하는 것을 다형성이라고 합니다.
대표적으로 오버라이드(클래스)와 오버라이딩(함수, 매서드)의 차이를 예를 들 수 있습니다.

4. 추상화
※  불필요한 부분을 제거하고, 공통적인 부분과 특징 특성을 분리 추출하여 재조합과 재구성 하는 것을 추상화라고 합니다.
-> 추상화를 통해서 코드의 재사용성과 가독성이 높아지고 유지보수에 있어 많은 시간을 절약할 수 있습니다.

07. 객체지향 5대 설계 원칙에 대해 설명해 보시오.
ㄴ
SRP -> 단일책임의 원칙. -> 결합도는 낮추고, 응집도는 높이는 것입니다.
결합도는 모듈간의 상호 의존 정도, 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성이라고 얘기할 수 있다.
OCP -> 개방-폐쇄의 원칙. -> 자신의 확장성에는 열려있고, 주변의 변화에 있어서는 닫혀있어야 된다는 것입니다.
LSP -> 리스코프 치환의 원칙 -> 하위 객체는 언제든지 상위 객체로 대체 될 수 있다는 것입니다. 이를 업캐스팅이라고 합니다.
ISP -> 인터페이스 분리의 원칙. -> 자신이 사용하지 않는 함수나 매서드에 의존 관계를 맺지 않는 것입니다.
DIP -> 의존관계 역전의 원칙. -> 자신보다 변화하기 쉬운 것에는 의존 관계를 맺지 않는 것입니다.

08. 프레임워크와 라이브러리 차이점에 대해 알고 있는지?
ㄴ 1. 미주알 고주알..... 2. 엔진 팔이  3. 아무말 대잔치
ㄴ 제어 (IOC : 제어의 역전)
사용자에 의해 제어를 맡기냐, 라이브러리에 제어를 맡기냐 차이.
차이점
※ 프레임워크는 어플리케이션의 구조와 흐름을 제어하며, 일관된 개발 패턴을 제공합니다,
 반면에 라이브러리는 특정기능을 쉽게 사용할 수 있도록 도와주며, 개발자가 전체 흐름을 제어할 수 있게합니다.
-> 프레임워크 -> 구조가 이미 정의되어 있기 때문에, 유연성이 상대적으로 낮다. 개발자는 프레임워크의 규칙과 관습을
따라야 하며, 특정한 방식으로 개발을 해야 한다.
-> 라이브러리 -> 프로그램의 제어 흐름이 개발자에게 있기 때문에 유연성이 높다. 개발자는 자신이 필요로 하는 라이브러리의
기능만 선택해서 사용할 수 있고, 프로그램의 구조나 흐름은 자유롭게 설계할 수 있다.

09. 메가맨 해봤는지? 해봤다면 이와 비슷한 장르의 충돌처리는 어떻게 할건지 본인의 의견 제시.
ㄴ 픽셀 충돌.
※ 우선 캐릭터와 적과의 충돌처리는 계산량이 적고 직관적으로 구현 가능한 AABB 박스를 통해서 처리를 할 것이며,
캐릭터가 맵의 경사로를 타야 하는 경우에는 좀더 정확한 픽셀충돌을 사용할 것이며, 간단한 픽셀충돌 방식을 채용할 것입니다.
간단한 픽셀충돌이란, 두 개체의 박스 충돌을 감지 후, 박스 안의 실제 픽셀 데이터만을 비교하는 것입니다
1.정확한 픽셀충돌(Exact Pixel Collision) 두 이미지의 실제 픽셀 데이터를 비교하여 충돌을 감지.
-> 가장 정확하지만 이미지의 실제 형태와 크기를 반영하여 충돌을 감지하여 연산이 복잡하고 시간이 많이 걸릴 수 있음.
2.간단한 픽셀충돌(Simplified Pixel Collision)
-> 두 개체의 박스 충돌 감지 후, 박스 안의 실제 픽셀 데이터만을 비교. 즉 박스 충돌이 발생한 경우에만 충돌 검사.
-> 따라서 박스 충돌이 일어나지 않는 경우 픽셀 충돌을 검사하지 않기 때문에 일부 충돌을 놓칠 수 있다.
3.픽셀-좌표 충돌 감지
-> 캐릭터나 적의 픽셀 데이터를 기반으로 충돌 위치를 계산하는 방식.
-> 충돌 위치를 더욱 정밀하게 계산 하지만, 성능 저하를 초래.
4.컬러기반 충돌 감지
-> 픽셀의 색상 정보를 이용하여 충돌을 감지, 투명하지 않은 픽셀의 색상 값을 비교하여 충돌 여부를 판단.
-> 색상 기반으로 쉽게 구현 가능하며, 색상 정보가 겹치는 경우 정확도가 떨어질 수 있다.

10. 메모리란 : 설명해 주시오.
ㄴ 라이트 (Ram휘발성) / 딥
-> 데이터를 저장하는 장치로서, 주 저장장치와 보조저장장치가 있다.
-> CPU와 레지스터 클러스터 관계?
-> 스트림? 코어클럭 분할
-> 쓰레드? -> 언리얼 시작창을 누르기만 해도 쓴거다.
※  프로그래머가 필요에 의해 데이터를 저장하는 공간으로써, 레지스터, 캐시 메모리, 주기억장치, 보조기억장치가 있습니다.
레지스터 -> 용량은 작고, 가격은 비싸지만 CPU에 직접 연결되어 있기 때문에 연산 속도가 기억 장치들에 비해 빠릅니다.
캐시메모리 -> 데이터를 미리 복사해두는 임시 저장공간을 의미합니다.
주기억장치 -> 대표적으로 RAM이 있습니다. 데이터를 읽거나 쓰는 것이 가능하며, 응용 프로그램, 운영체제 등을 불러와 CPU가
			 작업할 수 있도록 하는 기억장치입니다. 대신 휘발성 메모리로서 전원이 끊어지면 데이터가 전부 지워집니다.
보조기억장치 -> 대표적으로 HDD와 SSD가 있습니다.

OS에 대한 메모리 컨택스 (메모리 누수)에 대해 설명할 수 있음 Ok
※ 메모리 영역은 코드, 데이터, 힙, 스택으로 이루어져 있는데, 코드영역은 실행할 프로그램의 코드가 저장되는 영역.
데이터 영역 -> 전역 변수와 정적 변수가 저장되는 영역.
힙 영역 -> 메모리의 힙 영역은 사용자가 직접 관리할 수 있는 그리고 해야만 하는 메모리영역. 동적으로 할당되고 해제된다.
스택 영역 -> 메모리의 스택 영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역.
※ 여기서 동적으로 메모리를 사용했을 때 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상이 생길 수 있는데 이걸
메모리 누수라 합니다. 스택은 스택오버플로우가 발생하면 바로 에러를 알아차릴 수 있지만, 동적할당이 이루어지는 힙영역은
문제 없이 잘 작동할 수 있기 때문에 이런 누수 현상이 발생할 수 있습니다.
※ 가비지 컬렉션이란? -> 프로그램에서 더이상 사용하지 않는 메모리를 자동으로 정리하는 것입니다. 동적 할당 된 메모리영역
가운데 사용하지 않는 영역을 탐지해 자동으로 해지하여, 메모리 누수를 막을 수 있습니다. 하지만 C++에는 없는 기능입니다.
-> 방법으로는 트레이싱방식이 있습니다. 한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리로 간주하고,
그 밖의 메모리를 해제하는 방식을 가리킵니다. 트레이싱 방식중 하나가 마크 앤 스윕이며, 일부는 가비지 컬렉팅 기법으로
참조 카운팅 방식을 사용합니다. 마크 앤 스윕이란 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후
삭제하는 마크 앤 스윕 방법입니다. 객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지
아닌지를 표시(마크) 합니다. 그러고 나서 표시 되지 않은 객체를 삭제(스윕)하는 단계를 통해 메모리를 해제합니다.
※ 메모리 단편화
-> 메모리 단편화란 사용하기에 충분한 양의 메모리가 존재는 하지만, 사실상 사용이 불가능한 2가지 경우가 있습니다.
1. 내부 단편화 -> 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당 되어 공간낭비시 발생합니다.
해결방안 :
	1. 세그멘테이션 : 가변 길이 방식의 대표 유형
	2. 메모리 풀 : 동적 할당의 방식 중 하나. 미리 필요한 만큼 할당 받아서 만들어 둔다.
2. 외부 단편화 -> 메모리가 할당되고 해제되는 작업이 반복될 때, 중간에 생기는 작은 메모리 공간에서 발생.
합쳤을 때의 메모리 공간은 많지만, 각각의 메모리 공간의 사이즈는 작으므로 발생한다.
해결방안 :
	1. storage compaction(압축) : 주기적으로 삭제 공간을 회수하여, 메모리 공간들을 정리 비용이 많이 들어 자주쓸수없다. (주로 정해진 주기에 따라서 실행)
	2. CoaleScing(통합) : 단편화로 인해 쪼개진 공간들 중 인접한 공간들을 합쳐서 더 크게 만드는 방식.
	3. Placemanet Startege(배치 전략) : 배치를 잘하는 방식을 사용하여 단편화의 발생 가능성을 최대한 줄이는 방식
	4. Paging(페이징) 기법 : 고정 길이 방식의 대표 유형. (가상 메모리를 사용하여 논리공간 페이지와 물리공간 프레임)

★★★
11. 직원들이 퇴근하고 혼자 있을 때 문제점 발견 / 본인은 어떻게 할것인가? (심야 / 새벽)
ㄴ. 내가 책임질 수 있는 일이 아니라면, 상사에게, 팀장에게 보고를 하여 알리는게 우선이다.
※ 우선적으로 제가 책임질 수 있는 일이 아니라면, 직장 상사에게, 혹은 팀장님에게 현재 상황에 어떤 문제가 있는지 정확히 보고를
하여 알리는 것이 가장 좋다고 생각합니다.

12. 본인의 성향? (리더? / 부하? / 참모?)
ㄴ 참모가 제일 무난하다.
※  저의 성향으로는 단순히 상사의 지시에 따르며 하나만 하는 부하직원이 아닌, 상사의 지시에 1개를 알려주면 10가지를 배우며,
상황에 따라 어떠한 방법이 특정 상황에 가장 적합할지 고민하고 행동하기에 참모에 비슷하다고 생각합니다.

13. 자기보다 나이가 어린 사람 / 혹은 아주 많은 사람 아래에서 일 할 수 있나?
ㄴ + 텃세 / 부당 상황.
※  저는 일 할 수 있다고 생각합니다. 왜냐하면 저는 일하는것에 있어 나이는 숫자에 불과하다고 생각하기 때문에
저보다 일을 잘한다면 당연히 저의 선배가 될 수 있다고 생각합니다. 그리고 텃세와 부당상황에 대해서는 개인적으로 해결할 수 있는
문제가 아니라면, 상사 혹은 팀장님께 도움을 요청하여 해결하도록 노력할 것 입니다.

★★★
14. 구조체 / 클래스 차이점?
ㄴ C++ 하고 C#을 나눠서 얘기하면 가산점. (언리얼을 썼기 때문에)
※  구조체와 클래스는 C++ 과 C#에서 모두 사용되며, 두 언어에서의 특성과 차이점이 있습니다.
먼저 C++ 에서는 기본 접근 제어 지시자가 구조체에서는 public, 클래스에서는 private 입니다.
그리고 구조체는 보통 값 타입으로 사용되고, 클래스는 참조 타입으로 사용 됩니다.
C#에서는 접근제어 지시자가 기본적으로 둘다 private 입니다.
-> 심화? 구조체는 값 타입으로 동작하며, 기본적으로 스택에 할당됩니다. 클래스는 참조 타입으로 동작하며, 힙에 할당됩니다.
구조체는 상속을 지원하지 않으며, 소멸자를 정의할 수 없습니다. 클래스는 상속과 소멸자를 지원한다.

15. LifeCycle 설명? (전 / 지 / 동) / 동작 방식?
ㄴ 전역변수, 지역변수, 동적할당.
-> Allocate -> Release -> Memory Pool + {}
ㄴ 변수의 메모리가 확보된 (Allocate) 시점부터 해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점
ㄴ 기본적으로 변수는 자신이 선언된 Scope 내에서 생성되고 소멸이 된다.
ㄴ 일반적으로 전역 -> 어플리케이션의 주기 / 지역 -> 함수의 주기
※  변수의 LifeCycle(생명주기)는 변수의 생성, 사용, 소멸 과정에 따라 다릅니다. 변수의 메모리가 확보된 (Allocate) 시점부터
해제되어, (Release) 가용 메모리 풀(Memory Pool)에 반환되는 시점입니다. 기본적으로 변수는 자신이 선언된 Scope 내에서
생성되고 소멸 됩니다.
-> BP의 LifeCycle은 알고있나요? (9/23)

ex) {}

for(size_t i = 0; i < length; i++)
{
	if()
	{
		/// 주석 내용~ {} 알려줄때는 / 3개쓰기
		{

		}
	}
}

16. 현재 읽고 있는 전공책.
 ㄴ 모던 시리즈(생각 잘하고 말하도록.) 드래곤, 스컬, 물, 노을, 공룡
※  현재 읽고 있는 책으로는 다이렉트는 드래곤 혹은 물방울 책을 참고하고 있고, CS 지식으로는 공룡책을 참고하여 공부하고있습니다.


17. A* 알고리즘 알고 있는지? 알고 있다면 동기화 기법? (2D 에서 쓸일이 많다.)
ㄴ 다익스트라 원리 채용한 알고리즘
 ㄴ 현재까지 가장 최소의 비용으로 도달한 지점부터 탐색한다.
ㄴ f(x) = g(x) + h(x)
 ㄴ 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색.
ㄴ g(x) : 현재 상태 비용
ㄴ h(x) : 현재에서 다음 휴리스틱
장점 : 쉽다. 이해하기 편하다. 자료구조를 안탄다. (어느것이든 돼서)
단점 : 느리다. 최적화를 해야 한다.
동기화 기법 : 구역을 나눠서 연산하는 방법, JPS(가지치기, 점프, 리서치) 등 다양한 기법이 있다.
개선안 : JPS(가지치기, 점프, 리서치) A* 의 개선판. 훨씬 빠름. (단점 : 중간중간이나, 듬성듬성 오브젝트가 많으면, 프로그램이 뻑 날 수 이씀)
※  A* 알고리즘이란 -> 그래프 탐색 알고리즘 중 하나로,
자신의 주변 노드를 탐색하여 갈 수 있는지 확인하고, 목표지점까지의 비용을 계산하여, 최소가 되는, 즉 최단 경로를 찾기 위해 사용되는 알고리즘입니다.
특히 2D 경로 탐색에서 주로 사용되며, 다익스트라 알고리즘과 최적 우선탐색의 조합으로 목표에 도달하는 비용을 예측하고 효율적으로
경로를 찾습니다. 공식으로는 현재상태비용, 현재에서 다음휴리스틱, 둘을 더한 값이 최소가 되는 지점을 우선적으로 탐색하는 것입니다.
개선안으로는 구역을 나눠서 연산하는 방법(다중 레벨 경로 탐색)과 JPS가 있습니다.

구역 나눠서 연산
※ 맵을 여러 구역으로 나누어 구역 간의 경로 정보를 미리 계산하여 큰 범위에서의 탐색을 줄임으로써 성능을 개선하는 방식입니다.
동작방식
1.맵 구분: 구역을 나눠서 연산하는 방법은 전체 맵을 여러 개의 작은 구역으로 나누고 구역들은 일종의 추상화된 노드라고 생각 하여
작은 구역들의 경계에서 이동 가능한 포탈 노드를 정의할 수 있습니다.
2.고수준 경로 탐색: 최단 경로를 구할 때 먼저 구역 간의 큰 그림에서 경로를 탐색합니다. 이때 구역 자체를 노드로 보고 경로를 찾습니다.
3.저수준 경로 탐색: 고수준에서 찾은 경로를 기준으로 세부적으로 각 구역 내부에서 최단 경로를 탐색합니다.

JPS(Jump Point Search)
※  불필요한 노드확장을 생략하고, 탐색할 필요가 없는 경로를 빠르게 건너뛰도록 최적화한 알고리즘입니다. A* 알고리즘은 모든 인접노드를
탐색하며 확장해 나가지만, JPS는 그리드에서 특정 점프포인트들만 탐색합니다. 즉, 불필요한 노드 확장을 피하고, 경로의 핵심적인
전환점들만 찾아 나가는 방식입니다.
동작방식
1.일반화된 이동: JPS는 처음부터 모든 방향으로 최대한 멀리 이동합니다. 그리드 상에서 상하좌우 및 대각성 방향으로 최대한 멀리 이동 후
특정 조건에 따라 탐색을 중단하거나 계속 확장합니다.
그리드란? (행과 열로 이루어진 사각형, 즉 격자형태로 이루어진 구조를 말하며, 2D경로 탐색이나 시뮬레이션에 자주 사용됩니다.)
2.중간 노드 생략: 경로 상에 중요하지 않은 중간 노드들은 건너뛰고, 경로의 전환점이나 중요한 포인트(점프)에만 도달할 때까지 이동합니다.
점프포인트는 경로가 꺽이거나 회전해야 하는 중요한 지점. JPS는 이 점프 포인트만 탐색 대상으로 사용
3.휴리스틱 사용: A* 알고리즘의 공식을 사용하지만, 확장할 때 불필요한 중간 노드를 배제하여 성능을 높입니다.

블랙 A* (블록A*)
※  그리드의 작은 섹션에 있는 모든 가능한 경로를 포함하는 로컬 거리 데이터베이스를 생성합니다.
이 데이터베이스를 참조하여 조각별 임의 각도 경로를 빠르게 찾습니다.
모든 각도 경로 계획 알고리즘은 경로의 회전이 모든 각도를 가질 수 있도록 하면서 그리드 맵의 두 지점 사이의 유클리드 최단경로를
검색하는 경로찾기 알고리즘입니다. 그로 인해 열린 공간을 직접 통과하고 상대적으로 회전이 적은 경로가 생성 됩니다.
https://en.wikipedia.org/wiki/Any-angle_path_planning#A*-based

★★★
18. 포트폴리오를 제작하면서 다른 사람들부터 이런점은 내가 더 낫다? 혹은 어필하고 싶은 기능
ㄴ 무기를 만들때 추상 클래스를 활용하여 ~ 추가할 때 좀 더 용이하게 만들었다 등
※ 제 포트폴리오를 통해서 남들보다 더 낫다고 생각하는 것은, 추상 클래스를 활용하여, 확장성과 유지보수성을 높인 설계에 있습니다.
예를 들어, 여러 개의 비슷한 기능을 가진 스킬들을 관리하는 시스템에서, 공통된 인터페이스와 기본 동작을 추상 클래스에 정의해두면,
새로운 스킬을 추가할 때마다 전체 코드를 수정할 필요 없이 새로운 클래스에서 필요한 부분만 구현하면 되어 재사용성을 극대화하고
중복된 코드를 줄여주며, 유지보수에 좋게 설계했다고 생각합니다.


// 9 / 13
19. A* 2D / A* 3D 차이점에 대해 알고 있는지?
-> 2D는 현재 보여지는 영역(카메라가 보는)모든 영역을 검사.
-> 3D에서는 마우스로 입력 받을때 확인해야되는데, 캐릭터 반경에 원을 만들어두고, 반경까지만 검사. (처음에 벽을 찍어도 일단은 가는 이유)
   EQS?, 다익스트라.

※ 2D 에서는 X,Y 좌표를 사용하여, 4방향 또는 8방향으로 이동하며 현재 2차원 평면에서 보여지는 모든 영역을 검사하고,
거리계산으로는 2D는 멘해튼거리(상하좌우), 유클리드거리(대각선)로 계산, 3D는 체비셰프 거리(모든 방향)까지 계산합니다.
3D에서는 Voxel과 Navigation Mesh를 알고있는데, Voxel이란 Volume + Pixel의 합성어로 부피를 가진 픽셀이란 뜻을 가집니다.
3D 공간을 같은 크기의 정육면체로 나눈 단위라고 할 수 있습니다. 길찾기 원리로는 A* 알고리즘의 Start지점부터, End지점까지의
탐색 공간이 격자화 되어 그래프를 구성하게 되면 적용이 가능한데, Voxel로 공간을 분할하게 되면 2D와 마찬가지로 3D공간에서도
A*알고리즘을 적용할 수 있습니다. 특정 Voxel과 인접한 8개의 아웃 복셀들에 대해 A* 알고리즘에 필요한 상태값과 휴리스틱 값을
계산하면서 최단 경로를 검색하게 됩니다.
Navigation Mesh는 바닥, 장애물과 같은 게임월드의 정보를 미리 저장해두고, 이동할 때 저장된 정보를 바탕으로 장애물을 피해
목표 위치까지 이동하는 경로 탐색을 제공하는 것입니다.

EQS란 (Environment Query System)
 인공지능 분야에서 사용되는 시스템으로, 환경 정보를 기반으로 AI 캐릭터가 결정을 내리는데 도움을 주는 툴이며, 언리얼에서 주로
 사용 됩니다.
 AI 엔티티가 주변환경이나 레벨을 쿼리하여 사용 가능한 데이터를 얻게 해줍니다. EQS 쿼리를 사용하면 AI 캐릭터에게 플레이어를
 플레이어를 공격할 최적의 위치를 찾거나, 가장 가까운 회복 아이템을 찾도록 지시를 내릴 수 있습니다. 따라서 AI 엔티티의 주변을
 파악해야 하는 중요한 의사 결정에서 매우 유용합니다.
 1. 쿼리 -> 환경에서 특정 조건을 만족하는 객체나 위치를 찾는다.
 2. 필터링 -> AI가 필요로 하는 정보를 찾기 위해 여러 가지 필터를 적용할 수 있다.
 3. 컨텍스트 기반 -> AI가 현재 처한 상황을 반영해 적응형으로 행동할 수 있도록 환경 데이터를 제공한다.

다익스트라 알고리즘이란
-> 가중치가 있는 그래프에서 최단 경로를 찾기 위한 알고리즘입니다. A* 알고리즘과의 차이로는 휴리스틱 함수를 사용하지 않으며,
모든 경로를 동일하게 고려하여 최단경로를 찾습니다. 탐색 방식으로는 우선순위 큐를 사용하여 탐색하며 모든 노드의 최단 거리를 계산합니다.

20. STL 정의?
ㄴ 자료구조, 알고리즘을 템플릿화 시켜놓은 라이브러리.
※  표준 템플릿 라이브러리로,일반화된 다양한 자료구조와 알고리즘을 제공하는 것 입니다.
주로 컨테이너 (vector, list, deque, set, map 등이 있습니다.),
반복자(컨테이너 요소에 접근하고 순회, 반복자는 포인터처럼 작동하며, 요소들에 차례로 접근할 수 있게 해줌),
알고리즘(정렬, 탐색, 복사 등의 작업을 수행하는 함수)이 있습니다.

21. 본인의 코딩 스타일은 어떤가?
ㄴ 프로토타입을 먼저 작성한다.
※ 제 코딩 스타일은 객체지향적 프로그래밍을 중요시하여, 코드를 캡슐화 하여 데이터를 보호하고, 재사용하기 위해 상속,
다양한 상황에서 유연하게 동작하기 위해 다형성, 그리고 복잡한 로직을 단순화하고, 코드의 가독성을 높이기 위해 추상화를 적용하여
유지보수성이 뛰어난 코드를 작성하기 위해 노력합니다.

22. 참고하는 사이트?
ㄴ 마이크로 소프트 도큐먼트, C++ 레퍼런스, C++ 스택오버플로우
※ 제가 참고하는 사이트로는 마이크로 소프트 도큐먼트, C++ 레퍼런스가 있습니다.

언리얼에 들어간 DirectX의 개념은 공부를 했다.

23. 디자인 패턴에 대해 아는가?
ㄴ 프로그래머들이 개발하면서 발생하는 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안
※ 프로그래머들이 개발하면서 발생한 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안을 디자인 패턴이라고 합니다.

24. 알고있는 디자인 패턴? / 혹은 사용해야할 예시를 들어보시오. (GOF)
ㄴ 6 ~ 8개 알고있으면 좋은데, 포폴에서 쓴 디자인 패턴을 얘기하는게 가장 좋다.
컨택스트, 커맨드
싱글톤? 얘기를 할때 엄한거 얘기하지 말고, 언리얼 추상팩토리에 대해 얘기하는게 더 좋다.
※
1. 싱글톤
-> 특정 클래스의 인스턴스가 딱 하나만 존재하도록 보장하는 패턴이며, 전역 접근 가능하고, 필요할 때 최초로 인스턴스가 생성됩니다.
언리얼에서는 주로 게임 상태나 설정, 글로벌한 매니저 클래스 등을
하나의 인스턴스로 관리하려 할 때 종종 사용 되는 것으로 알고있습니다.
사용하는 이유
-> 한번도 사용하지 않는다면 아예 인스턴스를 생성하지 않습니다.(즉 초기화 되지 않습니다.)
-> 런타임에 초기화 됩니다. 컴파일러는 main 함수를 호출하기 전에 정적 변수를 초기화하기 때문에 프로그램이 실행된 다음에야 알 수
있는 정보를 활용할 수 없습니다. 하지만 싱글턴은 최대한 늦게 초기화 되기 때문에 클래스가 필요로 하는 정보는 준비가 되어 있습니다.
-> 싱글턴을 상속할 수 있습니다. -> 파일 시스템 래퍼가 크로스 플랫폼을 지원해야 한다면 추상 인터페이스를 만든 뒤, 플랫폼마다
구체 클래스를 만들면 됩니다.
단점 -> 클래스 사이의 의존성이 높아진다. (결합도가 낮아야 사용할 수 있습니다.)
-> 알고보니 전역 변수, 전역변수는 코드를 이해하기 어렵게 하며, 전역 변수는 커플링을 조장할 수 있고, 멀티스레딩 같은 동시성
프로그래밍에 알맞지 않습니다.

2. 상태 패턴
-> 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼
보입니다. 즉, 조건문이 아니라 객체의 상태를 별도의 클래스로 캡슐화하며, 객체는 Runtime에 자신의 행동을 변경합니다.
그래서 FSM(유한 상태 기계)를 언급할 수 있습니다.
FSM이란 -> 가질 수 있는 상태가 한정된다. 한 번에 한가지 상태만 될 수 있다. 입력이나 이벤트가 기계에 전달된다.
각 상태에는 입력에 따른 다음 상태로 바뀌는 전이가 있다.
단점 -> 상태 기계는 제한된 구조를 강제함으로써 복잡하게 얽힌 코드를 정리할 수 있게 해주지만, 하드코딩되어 있는 전이만이 존재합니다.
더 복잡한 곳에 적용하다 보면 한계에 부딪히는데 이를 위한 해결 방안으로 병형 상태 기계가 있습니다.
즉, 두 종류의 사태, 무엇을 하는가와 무엇을 들고 있는가를 두 개로 나누면 됩니다.

3. 관찰자 패턴 (Observer Pattern)
-> 객체 사이에 일 대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지
받고 자동으로 업데이트 될 수 있게 만듭니다.
단점 -> 등록한 관찰자를 삭제할 때 일련의 처리를 하지 않으면 불필요한 퍼포먼스 낭비가 일어날 가능성이 있습니다.

4. 명령 패턴(Command Pattern)
-> 요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기 시키거나 로깅하며, 되돌릴
수 있는 연산을 지원합니다. 따라서 요청 코드와, 수행 코드사이의 의존성을 줄이며, 입력 처리를 유연하게 관리하여
명령을 추가하거나 재사용이 쉬워집니다.

5. 컴포넌트 패턴 (Component Pattern)
-> 한 객체가 여러 분야를 서로 커플링 없이 다룰 수 있게 하는 것입니다. 부품을 조합하여, 복잡한 동작을 구현할 수 있고
게임 캐릭터를 레고 조립하듯이 구성하는 것입니다. 개별 컴포넌트를 재사용하여 개발시간을 줄이고, 유지보수를 쉽게 만듭니다.
-> 사용때 : 한클래스에서 여러 분야를 건드리고 있어서, 이들을 서로 디커플링하고 싶다, 클래스가 거대해져서 작업하기가 어렵다.
여러 다른 기능을 공유하는 다양한 객체를 정의하고 싶다. 단 상속으로는 딱 원하는 부분만 골라서 재사용할 수 가 없다.

6. 빌더 패턴 (Builder Pattern)
-> 복잡한 객체의 생성 과정을 단계별로 분리, 객체의 생성과 표현을 분리하는 것입니다. 생성하는 과정에서 서로 다른 표현을 가진
객체를 만드는 것이며 복잡한 게임 오브젝트나 레벨을 생성할 때 사용 됩니다.

7. 플라이웨이트 패턴 (Flyweight Pattern)
-> 메모리 사용은 최적화하기 위한 패턴이며, 객체의 공유를 촉진하는 형태입니다.
플라이 웨이트 패턴 상태 종류-> 변경 불가능한 공유상태, 객체마다 다를 수 있는 개별 상태가 있습니다.
공유상태는 객체 내부에 저장, 개별 상태는 클라이언트에 의해 관리됩니다. -> 대규모 게임 환경에서 반복되는 아이템을 관리할 때나,
모바일 게임에서도 유용합니다.

24 - 2 템플릿?

25. C / C++ 의 차이점?
ㄴ 객체냐 절차냐는 너무 라이트, 메모리에 대해서 얘기해야됨. 복사, 참조.
※ 우선 절차지향과 객체지향으로 나눌 수 있지만, 참조와 포인터 변수, Malloc과 New의 차이점을 말씀드릴 수 있습니다.
 우선 참조부터 말씀드리자면, C언어에는 참조자라는 개념이 없어, 주로 값 전달과 포인터를 사용하여 복사와 참조의 역할을 수행합니다.
C++에서는 참조자라는 개념이 도입되어, 더 직관적이고 안전한 방식으로 사용됩니다. 참조자란 실체가 있어야 하며, 즉시 할당되어야합니다.
즉 Null, Nullptr로 할당이 불가능합니다. 참조자는 초기화 리스트를 사용하여 먼저 초기화 해야하는데, 이는 생성자 내부에서의
초기화는 먼저 Null로 생성한 뒤 값을 넣는 방식이기 때문이며, 한 번 할당하면 다른 곳에 재할당 불가능합니다.
따라서 복사와 참조의 성능 차이로, 값에 의한 전달은 복사본을 생성하므로, 큰 객체를 전달할 때는 성능 문제가 발생할 수 있지만
참조에 의한 전달은 데이터를 복사하지 않고, 원본을 직접 참조하므로, 큰 데이터를 전달할 때 메모리 효율성이 높아집니다.
 다음으로, Malloc 과 New의 차이점으로는 Malloc은 단순한 메모리 할당이며 할당시 메모리의 사이즈를 입력해서 할당 받습니다.
Malloc은 Void*를 리턴하기 때문에 원하는 타입으로 캐스팅해서 사용 가능합니다.
New는 할당과 동시에 초기화 가능하며 초기값을 줄 수 있습니다. 생성자가 호출 됐을때, 오버로딩도 가능하며 할당시 객체의 크기를
입력하여 할당 받습니다.
1. new는 C++에서 제공하는 키워드 이지만 <-> malloc은 라이브러리 제공함수 입니다.
2. new는 할당할 타입을 지정하고, 해당 타입의 포인터를 Return 하지만,
   malloc은 필요한 메모리 양을 바이트 단위로 지정하고 void*로 Return 합니다.
3. new는 다른 연산자의 도움이 필요하지 않습니다 <-> malloc의 경우 sizeof 연산자와 cast의 도움이 필요합니다.
4. new는 메모리를 할당과 동시에 초기값을 줄 수 있습니다. <-> malloc은 메모리를 할당하는 것이 목적이기에 초기값을 줄 수 없습니다.
5. new는 재할당이 불가능하며, 새로운 변수를 만들어 대체할 땐 주소가 변경됩니다.
   malloc은 객체가 아니며 빈번하게 재할당할 경우 사용합니다.
6. new를 통한 할당은 delete로 해제해야 하며, 동적 메모리 할당을 해제하며 소멸자를 호출합니다.
   malloc을 통한 할당은 free로 해제해야 하며, 동적 메모리할당을 해제합니다.

- 이 질문은 어렵다..
26. C++ 왜 공부하는가? / 굳이 왜 C++?
ㄴ 내 스타일대로 설명할줄 알아야 할 것 같음.
들어가야할 것(메모리를 직접 관리 할 수 있다. -> 최적화 할 수 있는 것. 컴퓨터의 Low Level로 들어가 구조를 설명 할 줄 아는 것.)
Managed언어, UnManaged언어의 차이를 얘기할 수 도 있겠다.
※ 제가 C++을 공부하는 이유는 프로그래밍 언어 중에서도 고성능, 저수준 메모리 관리, 그리고 하드웨어와 밀접하게 연결된 개발을 할 수
있는 강력한 언어라고 생각해서 입니다. 게임에서는 단 1초가 아닌 밀리세컨드 단위로도 중요한 공간이기 때문에 이러한 성능과 제어가
중요한 프로그램을 개발하는데 최적화 된 언어는 C++이기 때문입니다.
 관리형 언어와 비관리형 언어의 차이를 들 수 있는데 C#과 자바는 가비지 컬렉션과 같은 자동 메모리 관리 기능을 사용하여 메모리 해제에
신경 쓰지 않도록 하지만 실시간 응답이 필요한 경우엔 성능이 떨어질 수 있습니다. 반면에 C++은 프로그래머의 역량에 따라 
메모리를 효율적으로 관리하여 성능을 최적화하고, 실시간 성능이 중요한 시스템에 적합합니다.
또 하드웨어와 가까운 레벨에서 프로그래밍할 수 있기 때문에 컴퓨터의 메모리 구조와 처리 과정을 이해하고 이를 최적화 하는데 유리합니다.
그렇기에 그래픽 엔진 개발에도 적합하다고 생각합니다.

27. 본인이 작업한 결과물중에 어떤걸 중점적으로 붙들고 공부해 보았는가?
ㄴ 포폴 -> 알고리즘이나 패턴, 설계가 들어가는게 좋다. AI / 캐릭터 / Anim 도 예를 들 수 있음.
※ 아직은 어떤걸 중점적으로 붙들고 공부할지 감이 안잡히지만, 캐릭터의 패턴이나, Animation 그리고 보스의 AI 시스템, 매쉬 절단을
중점적으로 공부해봐야되지 않을까 생각하고있습니다.

28. 희망 연봉?
ㄴ IT쪽은 상향해서 부르는게 좋다. 회사 내규에 따라서 주겠다 하면 -> 저는 그래도 3500~4000정도를 받았으면 좋겠습니다.
희망연봉 얘기하기.
※ 회사 내규에 따라야 된다면 따르겠지만, 저는 3500정도 받았으면 좋겠습니다.

29. 동료랑 의사 차이날때 어떻게 처리했는가?
ㄴ 사례 + 결국 내가 잘했다~ 중재를 했다~
※ 아직은 의사차이가 난 적이 없지만, 만약에 의사차이가 나게 된다면 우선 서로가 중요시하는 것이 무엇인지 파악하고, 중요시 하는 것을
둘다 해결하기 위한 방법이 있으면 찾아 보고 둘다 할 수 있으면 좋겠지만, 둘다 할 수 있는 시간이 없다면, 게임의 퀄리티를 좀 더 올릴 수
있는 것으로 설득하여 만드는 것을 결정하도록 하였습니다.

30. 상속의 장점에 대해?
ㄴ 추상 객체가 들어있다는 전제하에 얘기를 하는 것.
※ 장점으로는 공통되는 특징들을 다시 작성할 필요없이 필요한 기능이 담긴 클래스를 상속받으면 코드의 재사용성을 올릴 수 있습니다.

31. 다중 상속은 왜 조심해야 하는가?
ㄴ 다이아몬드 구조 -> 모호성 -> 인클루드가 깨져서 -> 상호참조가 발생한다.
※ 다중 상속의 문제는 2가지가 있는데, 첫 번째로는 여러 부모 클래스중 멤버 이름이 겹치는 경우입니다. 이 경우에는 사용자가 함수를
호출할 때 명확하게 하지 않으면 모호함이 발생하여 문제가 됩니다. 두 번째로는 다이아몬드 상속의 문제입니다. 정의된 함수를 호출할 때,
모호함이 발생하며 중복 상속으로 인해 동일한 멤버가 여러번 포함 될 수 있어 복사가 이루어져 비효율적으로 메모리를 차지하거나, 코드의
비일관성 문제를 유발할 수 있습니다. 그리고 상호참조가 발생하여 어떤 상속 경로를 통해 호출 됐는지 확인하기 복잡하고 어떠한 버그가
발생할지 모릅니다.

32. 지원자가 생각하는 랜더링 엔진은 무엇일까요?
ㄴ DX관한 질문임. 랜더링 파이프라인 -> 파이프라인을 공정해서 쓸 수 있냐?
-> 파이프라인을 커스텀 할 수 있는 라이브러리와 툴이 붙어있는 것이 엔진입니다. -> 이후 랜더링 파이프라인에 대해 언급.
※ 제가 생각하는 렌더링 엔진이란 렌더링 파이프라인을 커스텀 할 수 있는 라이브러리와 툴이 붙어있는 것이 엔진이라고 생각합니다.
렌더링 파이프의 구조는
1. Input Assember -> 파이프 라인을 시작하기 위한 초기 값을 입력 받는 단계입니다.
2. Vertex Shader -> IA가 넘겨준 정점을 이용해 한번에 하나씩 처리하는 단계입니다. 변환 행렬을 적용하거나, 정점 별 조명계산등을
					수행하는 단계입니다.
3. Hull Shader -> 도형을 얼마나 세밀하게 분할해야 하는지 계수를 결정하거나 도메인 셰이더에서 도형을 실제로 분할할 때 사용할 점들을
				  만들어냅니다.
4. Tesellator -> 헐 셰이더의 계획에 따라 실제로 폴리곤 분할을 수행하는 단계입니다.
5. Domain Shader -> 새로운 정점들을 생성하는 단계입니다. 분할할지 결정하고 -> 분할 수행하고 -> 새로운 정점 생성.
6. Geometry Shader -> 완성된 형태의 기본 도형들을 처리하거나 생성하는 단계입니다. 해당 단계에서는 파이프라인에 새로운 자료 요소를
					추가하거나 제거할 수 있습니다. 버텍스 쉐이더에서 생성되지 않은 임의의 도형을 생성하거나 수정할 수 있는 쉐이더.
7. Rasterizer -> 지오메트리 쉐이더로부터 출력된 데이터는 레스터라이저 단계로 보내져 렌더링 할 픽셀 단위로 분해됩니다.
-> 쉐이더 단계를 거친 도형이 픽셀로 변경되는 단계입니다. 정점들 사이의 공간을 픽셀로 채워 각 픽셀들은 픽셀 위치에 맞는 보간된 값을
가지게 됩니다.
8. Pixel Shader -> 각 픽셀마다 한번씩 수행되는 단계입니다. 파이프라인에 연결된 각 렌더 타겟을 위한 색상 값을 출력하며, 여러 텍스처
에서 샘플링을 하거나 주어진 픽셀의 값들로 계산을 수행합니다.

33. MVC 패턴에 대해 알고 있는가?
ㄴ Model / View / Controller
ㄴ 프로젝트를 구성할 때 그 구성요소들 (세가지로 나눈 패턴)
사용할때는 Controller -> Model -> View
Controller -> 입력 발생 (서비스)
Model -> 입력에 대한 처리 발생
View -> 보여지는 것.
※ MVC 패턴이란 Model View Controller로 나누어 책임을 분리함으로써 유지 보수성과 확장성을 높이는 것을 목표로 사용 하는 것입니다.
모델의 역할은 에플리케이션의 데이터와 입력 로직을 담당하는 부분입니다. View의 역할은 사용자가 볼 수 있는 화면을 담당합니다.
Controller는 Model과 View 사이의 중간 역할로 사용자의 입력을 받아 Model을 업데이트하거나, 필요한 데이터를 Model로 부터 받아
View에 전달합니다. 사용할때는 사용자의 입력, Controller, Model, View 순으로 업데이트 됩니다.
장점 : 1. 유지보수성 향상, 2. 책임분리, 3. 재사용성, 4.테스트 용이성.
단점 : 1. 복잡성 증가, 2. 컨트롤러의 복잡도, 3. View와 Model의 의존성
사용되는 예 : 1. 웹 프레임워크, 2. 데스크톱 에플리케이션

34. 오버로딩 / 오버라이딩의 개념 및 차이점.
ㄴ 요약(용어) -> 부가 설명. 중복 정의와 재정의가 있습니다. -> 부가적으로 설명을 드리자면 ~
오버로딩에서 오름차순 정렬?
※ 오버로딩과 오버라이딩의 차이점으로는 중복 정의와 재정의가 있습니다. 부가적으로 설명 드리자면 함수의 오버로딩은 같은 형태의 이름을 띄고
있지만, 매개변수, 인자의 개수 또는 타입에 따라 여러개 중복 정의할 수 있는 기능입니다. 클래스의 오버라이딩은 상위의 추상 클래스로부터
상속을 받았을 때 같은 매소드 및 함수를 사용할 때 하위 객체에서 새롭게 재정의하여 다르게 동작하도록 만들 수 있습니다.
? 오버로딩을 통해서 값을 저장할 때 오름차순이나 내림차순으로 저장하는 방법도 가능합니다.? 찾아봐도 잘 안나옴.

35. 스택 / 힙 ?
ㄴ 요약 (용어) -> 부가 설명
※ 스택과 힙은 메모리 영역을 설명할 수 있습니다. 스택은 컴파일시 stack 영역에 할당되며, 정적 영역으로 지역변수, 매개변수를 의미합니다.
따라서 컴파일 이후 크기를 변경할 수 없어 크기를 상수로 명시해야합니다. 그리고 메모리 누수를 걱정하지 않아도 되지만, 할당 받는 메모리 공간이
사용할 크기보다 크다면 공간의 낭비가 발생할 수 있습니다.
힙은 동적 영역으로 사용자의 할당영역이라 사용자에 의해 할당 되거나 소멸 됩니다. 그리고 런타임에 크기가 결정 되며, 동적으로 배열을 할당할 때
도 쓰일 수 있습니다. 따라서 언제나 원하는 만큼의 메모리가 맞춤으로 할당 될 수 있지만 사용하지 않는 공간을 해제 해주지 않는다면 메모리누수가
발생하게 됩니다.

36. 스택의 용량 알고 있는가?
ㄴ Default는 1MB 입니다. 늘리거나 줄일 수 있습니다.
-> 가변적으로 사용할 수 있지만 기본값은 1MB 입니다.
※ 기본 스택 크기는 1MB 이지만 가변적으로 사용할 수 있습니다. 용량을 늘려 사용하면, 시간을 줄일 수 있지만 메모리 요구 사항이 늘어나고
시작시간이 오래걸릴 수 있습니다. 그래서 될 수 있으면 큰 객체는 힙에 놓고 필요할 때만 스택의 크기를 늘리는게 좋습니다.

37. 아스키 / 유니코드의 차이점.
ㄴ Locale 헤더, 아스키와 유니코드는 별도이며 서로의 차이점을 얘기하면 좋을 것
※ 아스키 코드란 정보교환을 위한 미국 표준 코드이며, 7bit 문자 인코딩 시스템으로 128개의 문자를 정의합니다. 나머지 1비트는
패러티비트로 데이터 에러의 탐지를 위해 사용합니다.
-패러티비트는 데이터의 전달 과정에서 오류가 생겼는지 검사하기 위해 일곱자리의 이진수에서 1이 홀수개라면 끝에 1을 붙이고,
짝수개라면 끝에 0을 붙입니다.
※ 유니코드란 전 세계의 모든 문자를 하나로 통일된 문자집합으로 표현하고자 만든 것이 유니코드 입니다. 유니코드는 2바이트를 사용
하고, 다양한 언어와 특수 문자를 지원하여 글로벌한 어플리케이션 개발에 유리합니다. 따라서 아스키 코드는 단일바이트이며
유니코드는 멀티바이트 형식으로 사용됩니다.
그리고 유니코드에서는 UTF-8과 UTF-16을 나눌 수 있는데 UTF-8은 1바이트에서 최대 4바이트까지 사용해 다양한 문자를 나타내고,
16은 고정 길이 인코딩 방식으로 기본적으로 2바이트를 사용하지만, 특정한 데이터가 어떠한 기준이되는 크기의 블록 단위로
처리 되는 것으로 2바이트 혹은 4바이트로 인코딩 되는 방식입니다. 따라서 모든 크기가 동일한 16이 문자를 다루기 편하지만,
1byte로 표현할 수 있는 영어와 숫자가 2byte로 표현 되므로 환경에 맞게 사용해야합니다.
그래서 그 지역의 언어 및 요소를 나타내는 정보로 Locale헤더를 통해 사용자의 언어 및 지역에 따라 콘텐츠를 다르게 표시할 때
사용합니다.

38. 블루프린트를 사용하셨는데 장점과 단점은 무엇이라고 생각하는지?
ㄴ 최적화 얘기도 좋지만, 메모리 얘기를 하는게 좋지 않을지. -> 인클루드로 인한 메모리가 느리며, 속도가 느리다.
장점 -> 추상적 객체에 적용하는 것이 좋다. 전체적으로 상호작용을 할 때(문, 물건 등등), 애니메이션을 블루프린트로 하는 것이 훨씬 유리하다.
단점 -> 
※ 블루프린트의 장점으로는 시각적 표현, 프로토타입 제작, 비전공자 접근성, 코드와 완전 호환되어 디버깅 용이성이 있는점을 말할 수 있습니다.
- 시각적 표현으로는 드래그 앤 드롭 방식으로 동작을 표현하기 때문에 잘 활용한다면 시각적으로 복잡한 게임 로직을 구현할 수 있습니다.
- 빠른 프로토 타입 제작과 C++ 코드를 함께 사용하여 개발 속도를 높일 수 있습니다.
- 비전공자 접근성은 프로그래밍 경험이 없는 사람도 쉽게 접근할 수 있다는 점입니다.
- 디버깅 용이성은 블루프린트는 시각적으로 연결된 노드를 통해 동작을 표현하기 때문에 문제를 찾고 수정하는 것이 더 직관적일 수 있습니다.
단점으로는 성능문제, 가독성, 전환 문제, 제한된 기능, 완전한 제어가 어려운 점이 있습니다.
- 성능 문제로는 인클루드로 인한 메모리를 사용하여 일반적인 프로그래밍 언어보다 느린 속도로 동작할 수 있습니다.
- 가독성으로는 복잡한 로직의 경우엔 오히려 블루프린트가 너무 복잡해 질 수 있습니다.
- 전환 문제는 블루프린트를 C++로 변환하는 과정이 번거로울 수 있습니다. 최적화를 위해 코드로 전환할 피룡가 있을때 어려움을 겪을 수 있습니다.
- 제한된 기능으로는 일부 고급 기능은 블푸로 구현하기 어렵거나 불가능할 수 있어 C++과의 결합이 필요합니다.
- 완전한 제어는 C++ 코드로 구현한 것과는 다르게 완전한 제어권이 없으므로 제한적인 부분이 있을 수 있습니다.

39. 챗 AI 플랫폼 사용하나? / 사용한다면 이유는?
ㄴ 사용한다면 작업할 때의 효율을 얘기하면 될 것. 역량 문제에 치우치는 얘기는 안들어갔으면 함.
※ 저는 AI 챗 플랫폼을 사용하고 있습니다. 마이크로소프트에서도 코파일럿을 통해 정보를 얻거나, 문서를 정리하고 발표자료를
만드는 데에도 5분이면 만들어 시간적으로도 절약 하여 사용하기 때문에 저도 무엇인가의 정보를 이해하기 위해 틀렸는지 확인하고
주로 문서를 정리할 때 사용하고 있습니다.

40. 최근 관심 있는 이슈는?
ㄴ 업계에 대한 관심 얘기 (범용적), 생각하는 것에 대해선 얘기하지 않기.
※ 게임 질병화에 대해서 인과관계로 다시 이슈 되고 있는거로 알고있습니다. 원시적 그래픽의 게임들이 직접 조작한다는 이유만으로, 게임이 더
현실적이기 때문에 위험하다는 얘기가 있다는 것으로 알고있습니다. 반대로 게임과 폭력성은 서로 음의 상관관계, 반비례하는 것으로 게임업계의
전체 매출이 늘어날수록, 게임 검색량이 늘어날수록 폭력범죄 발생수도 줄어들었다는 정보가 있다는 것을 알고있습니다.

41. 혹시 학원에서 배운거 외에 따로 공부한거나 혹은 본인이 알고 있는 지식중에 남에게 설명할 수 있는가? (상대방은 모른다고 가정)
※ 저는 메모리 단편화에 대해서 설명하도록 하겠습니다. 메모리 단편화란 사용하기에 충분한 양의 메모리가 존재는 하지만 사실상 사용이
불가능한 경우입니다. 여기서 2가지의 경우가 있는데 내부와 외부 단편화가 있습니다. 내부 단편화란 메모리를 할당할 때 프로세스가
필요한 양보다 더 큰 메모리가 할당되어 공간 낭비시 발생합니다. 외부 단편화란 메모리가 할당되고 해제되는 작업이 반복될 때 중간에 생기는
작은 메모리 공간에서 발생합니다. 이러한 메모리 파편화 문제를 해결하기 위한 방법이 있는데 내부단편화에서는 세그멘테이션, 메모리풀이 있고
외부단편화에서는 압축, 통합, 배치전략, 페이징이 있습니다.
- 세그멘테이션은 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하게 하는
방법입니다. 따라서 동일한 크기의 모음으로 인식하기 보다는 함수는 함수대로, 자료구조는 자료구조대로 단위별로 메모리 상에 존재하는 것으로
인식합니다.
각 세그먼트는 연속적인 공간에 저장되어있어, 내부 단편화는 존재하지 X 중간에 메모리를 해제한다면 외부 단편화 문제가 발생할 수 있습니다. 
- 메모리풀이은 동적 할당의 방식 중 하나로 미리 필요한 지정해둔 크기만큼 할당 받아서 만들어 두고 필요할 때 마다 사용하고 반납하는
방식입니다.
다음으로 외부 단편화에서
- 압축은 메모리 공간을 재배치하여 단편화로 인해 분산되어 있던 메모리 공간들을 하나로 합치는 기법입니다. 대신 비용이 많이 들어
자주 사용할 수 없어 주로 정해진 주기에 따라서 실행됩니다.
- 통합은 단편화로 인해 쪼개진 공간들 중 인접한 공간들을 합쳐서 더 크게 만드는 방식입니다.
- 배치 전략은 배치를 잘하는 방식을 사용하여 단편화의 발생 가능성을 최대한 줄이는 방식입니다.
- 페이징 기법은 고정 길이 방식의 대표 유형으로 가상 메모리를 사용하며 논리공간 페이지와 물리공간 프레임이 있습니다. 논리 주소의
고정된 페이지라 불리는 블록들로 분할 관리하는 기법으로 프로세스 일정 크기인 페이지로 잘라 메모리를 적재하는 방식이며 물리주소 공간에
하나의 프로세스를 연속적으로 배치할 필요가 없어집니다.
프로세스(논리주소)를 자르고 실제 메모리(물리주소)에 매핑. 논리 주소는 CPU가 생성한 가상주소이고, 물리주소는 CPU가 제공한 논리 주소와
매핑된 실제 메모리의 주소입니다. 페이징의 경우 내부 단편화는 존재하지만, 외부단편화는 존재하지 않습니다.

42. 개발을 할 때 OOP가 효율적일까? 아니면 컴포넌트가 효율적일까?
ㄴ 케바케이며, 개발기간이 짧으면 OOP
-> 경우에 따라 다릅니다. 프로토타이핑처럼 빠르게 개발이 필요한 경우에는 코드 재사용성이 높은 OOP가 효율적이나,
라이브 시스템과 같이 유지보수가 지속적으로 필요한 경우에는 컴포넌트가 효율적입니다.
-> 서버가 붙는다면?
※ 경우에 따라 다르다고 말씀드릴 수 있습니다. 프로토타이핑에서는 OOP가 코드 재사용성 덕분에 효율적일 수 있습니다. 특히 로직 중심의
애플리케이션이라면 oop로 빠르게 기본 구조를 잡을 수 있습니다. 하지만 라이브 시스템과 같이 지속적인 유지보수와 UI 중심의 애플리케이션에서는
컴포넌트 기반 개발이 더 적합합니다. 변경이 자주 발생하는 시스템에서는 컴포넌트를 분리하여 개별적으로 관리하는 것이 더 용이합니다.
서버가 붙었을 경우에는 백엔드에서는 데이터 관리가 중요한 부분에서는 객체지향 모델링을 통해 도메인 개념을 잘 반영할 수 있으며 이를 통해
계층적 구조, 비즈니스 로직의 분리, 재사용성을 확보할 수 있어 OOP가 유리합니다.
 프론트엔드에서는 모두 컴포넌트 단위로, UI와 로직을 사용하기 때문에, UI를 독립적으로 관리함으로써 재사용성과 테스트 용이성을 높일 수 있어
 컴포넌트 기반에 적합하다고 생각합니다. 따라서 개발할땐 이를 결합하여 사용할 것이라 생각합니다.

43. Vector / List 차이점?
ㄴ 삽입과 삭제에 대해 오버헤드?
※ 벡터와 리스트의 차이점으로는, 벡터는 동적배열이며 배열과 같이 연속된 메모리 공간에 저장되므로 캐시 친화적이고,
배열의 원소에 임의 접근 가능합니다.
하지만 리스트는 단방향/양방향 반복자를 사용하여 임의 접근이 불가능하므로, 원소에 접근하기 위해선 해당 위치까지 순회해야 합니다.
대신 삽입 삭제에서 차이가 있는데, 리스트는 포인터를 사용하여 서로를 연결하니 삽입 삭제가 빈번한 구조에 사용하기 좋습니다. 왜냐하면
삽입 시에는 노드를 끊고 새로운 노드를 연결해주면 되고, 삭제 시에는 삭제할 노드의 연결을 끊고 다음 노드를 이어주면 되기 때문에 상대적으로
간단하게 처리할 수 있습니다.
반면 벡터에선 원소 삭제가 이루어지면 삭제된 위치 이후의 모든 원소를 전부 밀어주어야 하기 때문에 메모리 재할당이 일어 날 수 있습니다.
그렇지만 요소가 10000개 이하일 경우에는 벡터의 삽입 삭제가 더 빠른 것으로 알고있습니다.


44. 자료구조와 알고리즘에 대해 간략하게 설명해 보시오 / 혹은 가장 자신 있는것 1개씩만 대답해 보시오.
ㄴ
※ 프로그래머가 데이터를 어떻게 저장할지에 따라 결정되는 것을 자료구조라고 하고,
알고리즘은 문제를 해결하기 위해 정렬, 탐색등 문제의 해결 방법을 수행하는 함수입니다.
 저는 자료구조의 벡터에 대해서 설명해 보겠습니다. 벡터는 동적 배열로 크기가 자동으로 늘어나는 배열이며 연속적인 메모리 공간을 사용하여
데이터를 저장합니다. 벡터는 일반 배열처럼 사용할 수 있지만 크기가 가변적이어서 데이터를 추가할 때마다 자동으로 공간이 확장되는 특징이
있습니다. 따라서 연속적인 메모리 공간에 데이터를 저장하여 메모리를 효율적으로 사용 가능하게 하고, 인덱스를 통한 특정 위치의
요소에 임의 접근이 빠릅니다. 그리고 동적으로 크기를 관리하다 보니 메모리 재할당이 발생하는 경우 기존 크기의 2배 정도로 공간이 확장 됩니다.
여기서 또 알아야 될 점이 있는데 erase와 pop_back으로 인한 요소를 제거하더라도, Size는 감소하지만 벡터가 재할당 없이 저장할 수 있는
최대 요소의 개수 capacity는 줄어들지 않습니다. 그래서 capacity까지 줄이고 싶으면 shrink_to_fit()함수를 호출하여야 됩니다.
다음으로 삽입 삭제에서는 중간에 데이터를 삽입삭제시 해당 위치 이후의 모든 요소를 한 칸씩 이동해야 하므로 메모리 재할당이 일어날 수 있습니다.
따라서 엄청 많은 데이터를 메모리 재할당으로 복사가 이루어지면 성능에 영향을 미칠 수 있습니다.


45. 다른 사람의 코드를 보고 해석하는 능력이 어느정도 된다고 생각하는지?
ㄴ 중 정도는 되도록 대비
중 정도라 생각합니다 -> 왜? -> 상대방이 생각했을때 그게 아니라하면 개인적으로 생각했을때 그랬지만, 조금 더 객관화 시켜서 보도록 하겠습니다.
※ 저는 다른사람들의 코드를 많이 봐오지는 못 했지만 상황에 따라 중 정도라 생각합니다. 왜냐하면 구조가 잘 짜여진 코드나 가독성이 좋은 코드를
보았을 때에는 전체적인 흐름이 어떻게 흘러가는지 파악하고 이해할 수 있지만, 복잡하게 짜여진 코드라면 어떤 동작, 구현을 하는지 이해하는데
시간이 걸리기 때문에 중 정도라고 생각했습니다.

46. 머터리얼이 무엇인가? / 혹은 언제 적용해 보았는가?
ㄴ suface 비주얼 이펙트 -> 포폴에서 어디에서 적용해 보았다.
머터리얼은 기본적으로 Suface에 적용할 수 있는 미리 빌드된 비주얼 이펙트라고 할 수 있다.
ㄴ 텍스처 / 색상 / 거칠기 / 빛 등 모든 서피스 디테일에 관여할 수 있다.
-> 3D 외형을 설정하기 위한 주요 수단이라고 이해하면 좋겠다.
-> 여기서는 이미지 기반 반사부터 표현에 이르기까지 모든것을 머터리얼로 처리 할 수 있고, 셰이더 처리 또한
여기서 발생한다.
-> 재질 교체를 위해서는 머터리얼을 사용하자.
※ 머터리얼은 3D 모델의 표면(Suface)에 적용할 수 있는 미리 빌드된 비주얼 이팩트를 의미합니다. 이는 3D 모델의 외형을 설정하고, 표현을 풍부
하게 하기 위한 주요 수단입니다. 다양한 서피스 디테일을 제어할 수 있어, 텍스처, 색상, 거칠기, 빛과 같은 요소를 머터리얼을 통해 관리합니다.
셰이더 처리 또한 여기서 발생합니다.

47. 협업을 할때 중요하게 생각하는 2가지가 있다면?
ㄴ 책임/★1.소통+/적극적인태도/0.선보고,후조치/★희생+ (야근까지 할 수 있다는 희생정신)
※ 제가 협업할 때 중요하게 생각하는 2가지는 첫째 소통이며, 2번째는 희생정신이라고 생각합니다. 왜냐하면 첫 번째로 제가 맡은 역할과 책임을
정확히 이해하고, 오해가 생기지 않도록 구체적으로 소통하는 것이 필수라고 생각합니다. 그리고 현재 내가 맡은 프로젝트의 진행 상황과
발생한 문제, 앞으로의 계획을 정확하게 전달해야 프로젝트 진행 상황에 문제가 발생하지 않을 것이라 생각합니다.
두번째로 희생은 자신만의 이익이나 편의보다 팀, 회사의 목표를 우선시하는 마음가짐을 뜻하여 프로젝트의 마감기한을 지키기 위해 필요할 때에는
야근하여 성과를 낼 수 있도록 하는 것도 중요하다 생각합니다.

48. API에서 메시지 루프를 알고 있나?
ㄴ GetMessage, PeekMessage.
Get : 메세지 큐에서 꺼내올 놈이 있으면 대기
Peek : 메세지 큐의 최상단을 계속 확인.
※ 메시지 루프란 프로그램이 사용자 입력이나 시스템 메시지를 처리하는데 사용되며, GetMessage는 메세지 큐에서 메세지가 있을때까지 기다렸다가
메세지를 꺼내오고 없으면 대기 상태에 들어가 메세지가 발생할때까지 프로그램은 멈춰 있습니다. PeekMessage는 메세지 큐에 메시지가 있으면
바로 반환하고, 메세지가 없어도 바로 반환하는 비동기 함수입니다. 즉 메시지가 없을때 대기하지 않으며 프로그램은 계속 실행 돼 게임에서는
PeeKMessage를 사용합니다.

49. push_back / emplace_back의 차이점에 대해 알고 있는가?
ㄴ 컨테이너, 자료구조에 대해서 먼저 들어가서 push_back을 설명하고, emplace_back은 사용해본적 없지만, 생각을 유추해보자면~
emplace는 할당을 미리 크게 잡아, 할당을 배제하고 삽입하기 때문에 절차가 빠져 속도가 많이 오른다.
(메모리가 자주 들어오고, 자주 빠지는 구조는 emplace를 쓰는게 좋다.)
※ 벡터와 같은 동적 배열 컨테이너에서 주로 사용되는 함수이며 둘다 컨테이너의 끝에 요소를 추가하는 역할을 하지만, 동작 방식에는 중요한
차이가 있습니다. PushBack은 이미 생성된 객체를 추가하는 함수입니다. 즉 새로운 객체를 컨테이너에 삽입하려면, 해당 객체를 미리 생성해야합니다.
emplaceback은 객체를 컨테이너 내부에서 직접 생성하여 추가합니다. 즉 복사/이동 없이 emplace_back은 객체 생성과 삽입이 동시에 이루어져
복사/이동 오버헤드를 줄여 성능을 향상시킬 수 있습니다. 따라서 복사나 이동이 비싼 객체일수록 emplaceback의 이점이 큽니다.
메모리가 자주 들어오고 자주 빠지는 구조에서는 reverse를 사용하여 미리 공간을 확보하는게 좋다.

50. 다룰줄 아는 툴?
ㄴ 포토샵 / 오피스 세트 / Max, 마야, 블렌더(프로그램을 잘 다루기 보단 볼줄 안다 정도?) / 노션 / 트렐로?(스케줄 관리) / 코드 + 노트패드

51. 콜라이더의 종류 및 특징 (박스 / 쉐이프 / 메시 등등)
ㄴ 콜리전 / 콜라이더 (트리거 여부와 가장 큰 차이) 다이나믹인지 블록인지, 충돌 시킬지, 통과시킬지
ㄴ 단순콜리전, 복잡 콜리전, 메시 콜리전은 연산량이 높기 때문에 캐릭터에 한정해서 사용한다.
콜리전이 막는 것이며 지속성이 필요하고, 콜라이더는 단발성이 들어간다. 따라서 콜라이더가 가볍다.

52. 프로세스와 스레드 차이점?
ㄴ 프로세스
 ㄴ 메모리에 올라가 있는 프로그램 인스턴스 (최소 1개의 스레드를 가지고 있어야 한다.)
 ㄴ 프로그램 인스턴스이기 때문에 독립적으로 통신하기 위해서는 IPC를 사용해야 한다.
 ㄴ OS -> 독립된 메모리 영역을 할당 받는다. (다른 프로세스에 접근할 수 가 없다. (자원에 접근 X))

ㄴ 스레드
 ㄴ 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위
 ㄴ 스택 / 코드 / 데이터 / 힙
  ㄴ 스레드는 프로세스 내에서 스택만 따로 할당을 받는 구조를 가지고 있다.
   ㄴ 함수의 호출 정보를 확인해야 하기 때문에 스택만 별도로 할당
  ㄴ 나머지는 공유만 받는 메모리 영역이다.
 ㄴ 프로세스 내의 자원 공유
가비지 컬렉션이랑도 연결되어있다.


53. 희망 연봉과 맞지 않는다면 본인의 선택은?
ㄴ

54. 전방선언 / 전처리기문 차이점에 대해서?
ㄴ 복사의 수행 여부 (깊은 복사, 얕은 복사를 하는지 알아봐야한다.) 컴파일 타임에 걸리느냐, 안걸리느냐, 메모리를 소모하느냐? 소모하지 않느냐를 고려해야한다.