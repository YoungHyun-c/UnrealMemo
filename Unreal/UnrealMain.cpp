#pragma region 01
/*
Question
CodingInterview

01. 언리얼 설치?

◆ 트윈모션?
 ㄴ 포폴할때 필요한 경우가 생길 수 있다.
 ㄴ 리얼타임 3D 렌더링 구조 (시각화)

 02. VS 설치.
 ㄴ 2019 : 매크로를 사용 가능한 버전.
 ㄴ 2022 : 확장도구 플러그 인 사용 가능. Visual Studio Integration Tool
 -> 언리얼은 2022 쓸꺼임.

 03. 서브 에디터
  ㄴ VS Code / NotePad++ 설치

 04. 엔진 수업에 한계...
  ㄴ 집중 혹은 질문

 05. 포트폴리오 얘기
*/
#pragma endregion

// 9 / 11
#pragma region 02 9 / 11
/*
▶ 엔진?
-> 상용 / 자체

★★★
-> 엔진을 뭐라고 생각하는지? (정의?)
ㄴ 라이브러리 + 툴(에디터) -> 라이브러리의 집합이라 할 수 있고, 편리하게 사용하기 위한 툴
 ㄴ 언리얼3 / 크라이 엔진
 
-> 너희가 바라보고 있는 방향성
ㄴ 2D ? / 3D -> 수학과 물리로 귀결된다.

★
▶ 그래픽 프로그래밍
-> DX / OpenGL
 ㄴ 둘의 차이점? (이동 / 회전 / 전방) 이 다름. -> 작동 방식이 다르다.
 -> 좌표계가 다르다
 -> 왼손 좌표계는 회전축이 시계방향으로 돈다. (DX)
 -> 오른손 좌표계는 회전축이 반시계방향으로 돌아 음수값이 들어간다. (Op)
 -> 언리얼은 왼손 좌표계를 쓰는데, 왼손이나 오른손으로 스위칭 할 수 있다는게 중요하다.
 -> 왼손 : F(Z : Yaw) ( 1, 0, 0) / R(X : Roll) (0, 1, 0) / U(Y : ptich) (0, 0, 1)
  ㄴ 월드 매트릭스-> 
   ㄴ SRT, TRS
   ㄴ T이동 R회전 S비율 (월드에서의 객체의 속성값)
   TRS 월드 좌표 -> 절대좌표 -> 공간값이 바뀌지 않는 절대적 좌표.
   SRT 로컬 좌표 -> 상대좌표 -> 월드에 속해 있지만, 나 자신의 좌표.



★★★★★★★★★★
▶ 렌더링 파이프라인

 - 3D -> 2D

 -> 상용 엔진은 기본적으로 만드는 프로그램에 따라 효율적인 렌더링 파이프라인을 별개로 제공한다.
  ㄴ EX : Bullet-in / SRP / URP / HDRP(hign dynamic pipeline) 

 -> 파이프라인 -> 세부적인 내용은 조금씩 바뀐다.
 ㄴ 단, 큰 틀은 X

 -> Fixed Pipeline (정) / Programmable PipeLine (동)
  ㄴ 둘의 차이점으로는 GPU의 사용 여부.
  ㄴ 쉐이더의 값을 요구하는 경우가 많다.

 -> DX 9 / DX 10 / DX 11 / DX 12(의 순기능은 레이트레이싱)

 01. 로컬 스페이스
  ㄴ 0, 0, 0 절대 좌표. 디자인의 영역.

 02. 월드 스페이스
  ㄴ 가상의 3D 공간을 만든다. (SRT) 순서
  ㄴ 월드상 -> 정점 좌표

 03. 뷰
 ㄴ 일반적 -> 카메라
 ㄴ 가상의 3D 공간 -> 배치된 오브젝트를 실제 눈으로 보기 위해
 ㄴ ★ 이때 카메라를 기준으로 월드 -> 뷰 스페이스 좌표계로 투영이 발생.

 04. 백
 ㄴ 백 스페이스
 -> 후면 추려내기

 05. 조명
 -> 무덤, 공정
  ㄴ 최적화 라인
  ㄴ 크게 난반사 / 정반사
  ㄴ 여기서 다시 나누면 크게  4가지 Point(손전등) / Directional(태양) / Spot(정점) / Ambient(주변광)
   ㄴ 다시 여기서 4가지로 분기
    ㄴ Ambient / Diffuse(확산광) / Specular(반사광) / Emissive(방출)

 06. 클리핑
 ㄴ 카메라 안에 들어오는 것에 그리지 않겠다.
 ㄴ 오클루전 / 프러스텀
 -> 원하는 부분을 자르겠다.

 07. 프로젝션 (투영)
 ㄴ 3D -> 2D 표현을 얻는 과정
  ㄴ Perspective, Orsorgraphic

 - Perspective (원근)
 ㄴ 원근감 (크기에 따라 바뀌는 것)
 ㄴ 카메라 앞으로 올수록 스케일을 위 아래로 늘려 원근감 부여.

 - Orsographic (직교)
 ㄴ 오브젝트를 원근감 없이 수직 위에서 내려다 보듯이 투영.

 -> 클리핑 결과로 3D 좌표에서 2D 좌표계로 행렬 변환

 isometric -> 등축 투영법 물체를 눕힌것.

 08. 뷰포트
 ㄴ 뷰포트에 맞게 투영된 2D 좌표계를 매칭 시키는 작업
 ㄴ 모니터 화면으로 올려준다.

 09. 보간 (레스터 라이즈)
 ㄴ 폴리곤 -> 픽셀

 ==========================================

 01. IA

 02. 정점

 03. 헐

 04. 터셀레이터


*/
#pragma endregion


// 9 / 12
#pragma region 03 9 / 12
/*

-> 기본적으로 알아둬야 할 사항.

-> 언리얼 엔진 -> 상용 엔진 -> 렌더링 엔진

-> 현업 -> 엔진 파트에서는 보통 디자이너 / 프로그래밍 파트로만 나뉜다.

-> 디자이너 + 프로그래밍 = TA

-> 엔진을 잘 쓰고 싶다. -> 엔진 구조 파악 -> 언어, 수학 + 그래픽스
 ㄴ 라이브러리 + 툴(에디터) + 피직스s + FMOD(사운드 라이브러리 엔진) = 언리얼

- 언리얼 엔진은 기존의 포멧과 좌표축이 다르다.

-> 뷰포트 좌표계 기준으로 좌하단 (API 좌상단)
-> 왼손 좌표계 / SRT 
-> 엔진은 왜 혼합형(DX, OpenGL)으로 되어있나? OpenGL 플랫폼 때문에 사용하기 위해선 컨버팅해야됨
-> 언리얼은 DX 기반이지만, OpenGL도 혼합 가능.
OpenGL은 상용화가 잘 되어있음. (자판기, 에어컨 화면)

-> 각 객체들은 월드라는 공간을 가진다.
 ㄴ 이는 트랜스폼으로 표현.
 ㄴ 월드 -> 뷰 -> 프로젝션

 -> 언리얼은 최적화를 할 때 신경을 써야 할 점이 많지만 일단 기본적으로 정점에 대한 계산을
 항상 염두해 둬야 한다. (엔진 -> 렌더링 -> 정점 세이더)

 -> 필요에 의해서 포폴 -> 쉐이더 들어가면 좋지만 안들어 갈 시 -> 다른 기능으로 대체.

 
 - 아웃라이너

 - 검색에 관한 문법

 - 1. 그냥 (일반검색)
  ㄴ EX : Light

 - 2. - (일치하는 놈 제외)
  ㄴ EX : -Light

 - 3. + (정확하게 일치하는 놈)
  ㄴ EX : +Light

 - 4. "" (정확 -> 이름 및 소문자)
  ㄴ EX : "Light"

  폴더 중요
  1. ~~~_BP.unproject
  2. Content 폴더 : 메테리얼, 파일 컨텐츠에서 건들지 말 것.
  3. Config 폴더 : 지우면 안됨. 사용자의 매크로키 등 설정이 들어있음, 지우면 초기상태.
  4. Intermediate : 위와 동일. (작업하던것(탭, 작업창) 유지할지)
  5. Saved : 없어도 상관은없지만, 개인 작업물에 영향을 끼침
  ★ _BP.uproject와  Content만 살아있어도 살릴 가능성이 있음. ★

  DerivedDataCache : 지워도됨. (작업 찌꺼기)


  Json을 알아야됨!
  Json 파일을 수정하고, 설정해야되기 때문에 사용할 줄 알아야됨.
  ▶ JSON (JavaScript Object Notation)
  -> 제이슨은 객체의 구조와 속성을 텍스트 형식으로 전달하기 고안되었다.
  -> 제이슨에 초기 정보가 있디 깨문에 uproject파일을 클릭하거나 상호 작용 했을때 윈도우가 이를 인식하고
  처리를 해주는 것. (해당 되는 엔진 버전 + 해당 되는 플러그 인 + 초기화 필요한 모듈)
  -> 제이슨은 객체의 구조 + 속성을 텍스트 형식으로 전달하기 때문에 일단 항상 평균 이상의 퍼포먼스를 낼 수 있다.
  ㄴ + 확장성 좋고 (#include Json.hpp) (헤더와 CPP 합쳐놓은게 hpp)
  ㄴ + 텍스트 형식이 -> 사람도 좋고
  ㄴ + 문자열 기반이기 때문에 오버헤드가 적다.
  ㄴ + 자료형에 특별한 제한이 없다. -> 특히 컴퓨터의 변수값을 표현하는데 좋다.
  -> 제이슨 자체는 자바 스크립트로 만들었지만 프로그래밍 언어나 플랫폼에 독립적 -> 다양한 언어에서 사용 가능
  -> 항상 비교직군으로 떠오르는 CSV(알아야됨),를 기준으로 자름. / XML / HTTP 보다 일반적인 상황에서 더 좋은 퍼포먼스 보여준다. (strtok)
  ㄴ XML vs json

  -> 제이슨을 사용할때는 개발자가 일반적으로 직렬화 / 역직렬화 작업을 해줘야 한다.

  -> 현업에서 직렬화 / 역직렬화를 사용해야 하는 이유
  ㄴ 네트워크 데이터를 주고 받을 때 네트워크 스트림은 일반적인 바이너리 데이터만 보낼 수 있기 때문.

  {
  "FileVersion": 3,
    "Plugins": 
    [
        {
            "Name": "ModelingToolsEditorMode",
            "Enabled": true,
            "TargetAllowList": 
            [
                "Editor"
            ]
        }
    ]
  }

  {}: 객체
  키: 값-> 객체가 가질 속성
  "": 문자열 데이터
  []: 배열

               (비트나 바이트를 받음)
  클라 < --- > 서버
        동기화
      동기화를 해주기 위해서 직렬화, 역직렬화가 들어간다.


 언리얼
 -> 초기
 -> 파일 -> 새레벨 -> Basic
 -> 작업할때는 오른쪽 세팅-> 엔진 퀄리티 세팅 -> 중간옵션. -> 나중에 게임할때는 에픽
 -> 프레임 확인 -> 왼쪽 화면 삼 =_ 에서 FPS 표시 클릭
 -> 창 -> 엑터 배치, 메시지 로그, 출력 로그, 콘텐츠 브라우저 1, 2 두개 띄우기 (Ctrl + Space)
 -> 툴 -> 클래스 배치
 모드
 -> 라이팅 포함
 -> 언릿 -> 라이팅 끄기
 -> 와이어 프레임 -> 프레임이 떨어지면 정점이 많은거 확인해보기.
 -> 라이팅만 -> 빛 사용하는 것만
 -> 리플렉션 -> 거울? 모드
 -> 게임세팅 -> Ev100 -> 나중에 화면이 밝아지거나 어두워지는 효과 낼때 사용 (코드로 Export하기)
 프로젝트 복제
 -> 만들었던 프로젝트 -> 우클릭 -> 복제
 -> 생성 -> 계속
 -> 복제된 것 -> 우클릭 -> 폴더 보기 -> uproject파일이름변경 -> Config파일 -> DefaultEngine ->
 -> 맨위에
 [URL]
 GameName=Example 적음.
 그다음 상위 폴더로 가서, 폴더의 이름 Example로 변경 저장. -> 에픽게임즈 라이브러리 가서 보면 바뀌어있음.


*/
#pragma endregion