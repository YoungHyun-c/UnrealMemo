#pragma region 01
/*
Question
CodingInterview

01. 언리얼 설치?

◆ 트윈모션?
 ㄴ 포폴할때 필요한 경우가 생길 수 있다.
 ㄴ 리얼타임 3D 렌더링 구조 (시각화)

 02. VS 설치.
 ㄴ 2019 : 매크로를 사용 가능한 버전.
 ㄴ 2022 : 확장도구 플러그 인 사용 가능. Visual Studio Integration Tool
 -> 언리얼은 2022 쓸꺼임.

 03. 서브 에디터
  ㄴ VS Code / NotePad++ 설치

 04. 엔진 수업에 한계...
  ㄴ 집중 혹은 질문

 05. 포트폴리오 얘기
*/
#pragma endregion

// 9 / 11
#pragma region 02 9 / 11
/*
▶ 엔진?
-> 상용 / 자체

★★★
-> 엔진을 뭐라고 생각하는지? (정의?)
ㄴ 라이브러리 + 툴(에디터) -> 라이브러리의 집합이라 할 수 있고, 편리하게 사용하기 위한 툴
 ㄴ 언리얼3 / 크라이 엔진
 
-> 너희가 바라보고 있는 방향성
ㄴ 2D ? / 3D -> 수학과 물리로 귀결된다.

★
▶ 그래픽 프로그래밍
-> DX / OpenGL
 ㄴ 둘의 차이점? (이동 / 회전 / 전방) 이 다름. -> 작동 방식이 다르다.
 -> 좌표계가 다르다
 -> 왼손 좌표계는 회전축이 시계방향으로 돈다. (DX)
 -> 오른손 좌표계는 회전축이 반시계방향으로 돌아 음수값이 들어간다. (Op)
 -> 언리얼은 왼손 좌표계를 쓰는데, 왼손이나 오른손으로 스위칭 할 수 있다는게 중요하다.
 -> 왼손 : F(Z : Yaw) ( 1, 0, 0) / R(X : Roll) (0, 1, 0) / U(Y : ptich) (0, 0, 1)
  ㄴ 월드 매트릭스-> 
   ㄴ SRT, TRS
   ㄴ T이동 R회전 S비율 (월드에서의 객체의 속성값)
   TRS 월드 좌표 -> 절대좌표 -> 공간값이 바뀌지 않는 절대적 좌표.
   SRT 로컬 좌표 -> 상대좌표 -> 월드에 속해 있지만, 나 자신의 좌표.



★★★★★★★★★★
▶ 렌더링 파이프라인

 - 3D -> 2D

 -> 상용 엔진은 기본적으로 만드는 프로그램에 따라 효율적인 렌더링 파이프라인을 별개로 제공한다.
  ㄴ EX : Bullet-in / SRP / URP / HDRP(hign dynamic pipeline) 

 -> 파이프라인 -> 세부적인 내용은 조금씩 바뀐다.
 ㄴ 단, 큰 틀은 X

 -> Fixed Pipeline (정) / Programmable PipeLine (동)
  ㄴ 둘의 차이점으로는 GPU의 사용 여부.
  ㄴ 쉐이더의 값을 요구하는 경우가 많다.

 -> DX 9 / DX 10 / DX 11 / DX 12(의 순기능은 레이트레이싱)

 01. 로컬 스페이스
  ㄴ 0, 0, 0 절대 좌표. 디자인의 영역.

 02. 월드 스페이스
  ㄴ 가상의 3D 공간을 만든다. (SRT) 순서
  ㄴ 월드상 -> 정점 좌표

 03. 뷰
 ㄴ 일반적 -> 카메라
 ㄴ 가상의 3D 공간 -> 배치된 오브젝트를 실제 눈으로 보기 위해
 ㄴ ★ 이때 카메라를 기준으로 월드 -> 뷰 스페이스 좌표계로 투영이 발생.

 04. 백
 ㄴ 백 스페이스
 -> 후면 추려내기

 05. 조명
 -> 무덤, 공정
  ㄴ 최적화 라인
  ㄴ 크게 난반사 / 정반사
  ㄴ 여기서 다시 나누면 크게  4가지 Point(손전등) / Directional(태양) / Spot(정점) / Ambient(주변광)
   ㄴ 다시 여기서 4가지로 분기
    ㄴ Ambient / Diffuse(확산광) / Specular(반사광) / Emissive(방출)

 06. 클리핑
 ㄴ 카메라 안에 들어오는 것에 그리지 않겠다.
 ㄴ 오클루전 / 프러스텀
 -> 원하는 부분을 자르겠다.

 07. 프로젝션 (투영)
 ㄴ 3D -> 2D 표현을 얻는 과정
  ㄴ Perspective, Orsorgraphic

 - Perspective (원근)
 ㄴ 원근감 (크기에 따라 바뀌는 것)
 ㄴ 카메라 앞으로 올수록 스케일을 위 아래로 늘려 원근감 부여.

 - Orsographic (직교)
 ㄴ 오브젝트를 원근감 없이 수직 위에서 내려다 보듯이 투영.

 -> 클리핑 결과로 3D 좌표에서 2D 좌표계로 행렬 변환

 isometric -> 등축 투영법 물체를 눕힌것.

 08. 뷰포트
 ㄴ 뷰포트에 맞게 투영된 2D 좌표계를 매칭 시키는 작업
 ㄴ 모니터 화면으로 올려준다.

 09. 보간 (레스터 라이즈)
 ㄴ 폴리곤 -> 픽셀

 ==========================================

 01. IA

 02. 정점

 03. 헐

 04. 터셀레이터


*/
#pragma endregion


// 9 / 12
#pragma region 03 9 / 12
/*
-> 기본적으로 알아둬야 할 사항.

-> 언리얼 엔진 -> 상용 엔진 -> 렌더링 엔진

-> 현업 -> 엔진 파트에서는 보통 디자이너 / 프로그래밍 파트로만 나뉜다.

-> 디자이너 + 프로그래밍 = TA

-> 엔진을 잘 쓰고 싶다. -> 엔진 구조 파악 -> 언어, 수학 + 그래픽스
 ㄴ 라이브러리 + 툴(에디터) + 피직스s + FMOD(사운드 라이브러리 엔진) = 언리얼

- 언리얼 엔진은 기존의 포멧과 좌표축이 다르다.

-> 뷰포트 좌표계 기준으로 좌하단 (API 좌상단)
-> 왼손 좌표계 / SRT 
-> 엔진은 왜 혼합형(DX, OpenGL)으로 되어있나? OpenGL 플랫폼 때문에 사용하기 위해선 컨버팅해야됨
-> 언리얼은 DX 기반이지만, OpenGL도 혼합 가능.
OpenGL은 상용화가 잘 되어있음. (자판기, 에어컨 화면)

-> 각 객체들은 월드라는 공간을 가진다.
 ㄴ 이는 트랜스폼으로 표현.
 ㄴ 월드 -> 뷰 -> 프로젝션

 -> 언리얼은 최적화를 할 때 신경을 써야 할 점이 많지만 일단 기본적으로 정점에 대한 계산을
 항상 염두해 둬야 한다. (엔진 -> 렌더링 -> 정점 세이더)

 -> 필요에 의해서 포폴 -> 쉐이더 들어가면 좋지만 안들어 갈 시 -> 다른 기능으로 대체.

 
 - 아웃라이너

 - 검색에 관한 문법

 - 1. 그냥 (일반검색)
  ㄴ EX : Light

 - 2. - (일치하는 놈 제외)
  ㄴ EX : -Light

 - 3. + (정확하게 일치하는 놈)
  ㄴ EX : +Light

 - 4. "" (정확 -> 이름 및 소문자)
  ㄴ EX : "Light"

  폴더 중요
  1. ~~~_BP.unproject
  2. Content 폴더 : 메테리얼, 파일 컨텐츠에서 건들지 말 것.
  3. Config 폴더 : 지우면 안됨. 사용자의 매크로키 등 설정이 들어있음, 지우면 초기상태.
  4. Intermediate : 위와 동일. (작업하던것(탭, 작업창) 유지할지)
  5. Saved : 없어도 상관은없지만, 개인 작업물에 영향을 끼침
  ★ _BP.uproject와  Content만 살아있어도 살릴 가능성이 있음. ★

  DerivedDataCache : 지워도됨. (작업 찌꺼기)


  Json을 알아야됨!
  Json 파일을 수정하고, 설정해야되기 때문에 사용할 줄 알아야됨.
  ▶ JSON (JavaScript Object Notation)
  -> 제이슨은 객체의 구조와 속성을 텍스트 형식으로 전달하기 고안되었다.
  -> 제이슨에 초기 정보가 있디 깨문에 uproject파일을 클릭하거나 상호 작용 했을때 윈도우가 이를 인식하고
  처리를 해주는 것. (해당 되는 엔진 버전 + 해당 되는 플러그 인 + 초기화 필요한 모듈)
  -> 제이슨은 객체의 구조 + 속성을 텍스트 형식으로 전달하기 때문에 일단 항상 평균 이상의 퍼포먼스를 낼 수 있다.
  ㄴ + 확장성 좋고 (#include Json.hpp) (헤더와 CPP 합쳐놓은게 hpp)
  ㄴ + 텍스트 형식이 -> 사람도 좋고
  ㄴ + 문자열 기반이기 때문에 오버헤드가 적다.
  ㄴ + 자료형에 특별한 제한이 없다. -> 특히 컴퓨터의 변수값을 표현하는데 좋다.
  -> 제이슨 자체는 자바 스크립트로 만들었지만 프로그래밍 언어나 플랫폼에 독립적 -> 다양한 언어에서 사용 가능
  -> 항상 비교직군으로 떠오르는 CSV(알아야됨),를 기준으로 자름. / XML / HTTP 보다 일반적인 상황에서 더 좋은 퍼포먼스 보여준다. (strtok)
  ㄴ XML vs json

  -> 제이슨을 사용할때는 개발자가 일반적으로 직렬화 / 역직렬화 작업을 해줘야 한다.

  -> 현업에서 직렬화 / 역직렬화를 사용해야 하는 이유
  ㄴ 네트워크 데이터를 주고 받을 때 네트워크 스트림은 일반적인 바이너리 데이터만 보낼 수 있기 때문.

  {
  "FileVersion": 3,
    "Plugins": 
    [
        {
            "Name": "ModelingToolsEditorMode",
            "Enabled": true,
            "TargetAllowList": 
            [
                "Editor"
            ]
        }
    ]
  }

  {}: 객체
  키: 값-> 객체가 가질 속성
  "": 문자열 데이터
  []: 배열

               (비트나 바이트를 받음)
  클라 < --- > 서버
        동기화
      동기화를 해주기 위해서 직렬화, 역직렬화가 들어간다.


 언리얼
 -> 초기
 -> 파일 -> 새레벨 -> Basic
 -> 작업할때는 오른쪽 세팅-> 엔진 퀄리티 세팅 -> 중간옵션. -> 나중에 게임할때는 에픽
 -> 프레임 확인 -> 왼쪽 화면 삼 =_ 에서 FPS 표시 클릭
 -> 창 -> 엑터 배치, 메시지 로그, 출력 로그, 콘텐츠 브라우저 1, 2 두개 띄우기 (Ctrl + Space)
 -> 툴 -> 클래스 배치
 모드
 -> 라이팅 포함
 -> 언릿 -> 라이팅 끄기
 -> 와이어 프레임 -> 프레임이 떨어지면 정점이 많은거 확인해보기.
 -> 라이팅만 -> 빛 사용하는 것만
 -> 리플렉션 -> 거울? 모드
 -> 게임세팅 -> Ev100 -> 나중에 화면이 밝아지거나 어두워지는 효과 낼때 사용 (코드로 Export하기)
 프로젝트 복제
 -> 만들었던 프로젝트 -> 우클릭 -> 복제
 -> 생성 -> 계속
 -> 복제된 것 -> 우클릭 -> 폴더 보기 -> uproject파일이름변경 -> Config파일 -> DefaultEngine ->
 -> 맨위에
 [URL]
 GameName=Example 적음.
 그다음 상위 폴더로 가서, 폴더의 이름 Example로 변경 저장. -> 에픽게임즈 라이브러리 가서 보면 바뀌어있음.

*/
#pragma endregion

#pragma region 9 / 13
/*
▶ 효율은 모르겠지만 좋은 퀄리티를 보여주는 언리얼

- 장점
-> 멀티 플랫폼 지원 (크로스) 지원
-> 통합 개발 환경 지원 (IDE)
-> 빌드 및 모듈 시스템 (플러그 인)
-> 통합 에셋 관리 시스템 지원 (추상 팩토리)
ㄴ 오브젝트의 선언과 관리 시스템
-> 스크립팅 시스템 지원 (에디터 / 런)
-> 파티클 시스템 지원
-> 렌더링 시스템지원
-> 2D 시스템 지원
-> 셰이더 시스템 지원
-> 사운드 시스템 지원 (Fmod)
-> 물리 시스템 지원 (phys x)
-> 지형 시스템 지원 
-> 프로파일링 시스템 지원 
-> 마켓 플레이스 지원
-> 애니메이션 시스템 지원
-> 머터리얼 에디터 지원
- 5 한정 -> 나나이트 / 루멘

- 단점
-> 많이 많이 무겁다.
-> 많이 많이 느리다.
-> 입문 난이도가 높다.
 ㄴ 선행 지식이 많이 요구됨.
-> 활성화된 커뮤니티 없음. (만약 찾는 기능이 없으면 유니티로 대체해서 검색해서 찾아봐야 한다)

※ 언리얼 엔진은 C++ 스크립트를 통해 컴포넌트 프로그래밍 방식을 지원한다.
▶ 컴포넌트 프로그래밍
-> 기존 상속 기반 프로그래밍의 단점을 극복하기 위한 프로그래밍 방식
-> 상속 기반이 물체를 정의한 기능을 확장 시켜나가는 개념을 지닌것에 비해 컴포넌트 기반 프로그래밍은
기능을 모음으로서 물체를 정의하는 방식으로 접근한다.
-> 이러한 방식은 곧 덕 타이핑 개념이라고 불린다.

▶ 덕 타이핑 (Duck Typing) (STL 개념으로 만들어져 있어 써봤다)
-> 동적 타이핑의 한 종류라고 생각하면 된다.
ㄴ 객체의 변수 및 매서드의 집합이 객체의 타입을 결정하는 것을 뜻한다. (행위도 결정할 수 있다)
-> 프레임워크 설계가 정말 중요하다.
Managed 와 UnManged 차이? 메모리 관리 주체 (컴퓨터 or 나) (RIL / T-S ?) 포인터 -> * 나
Managed(컴퓨터) 가비지 컬렉션
UnManaged(나) T-S 나 -> * 포인터- > 로우/하이?

-> 장점 (부위파괴?)
-> 상속 기반 프로그래밍이 유연하지 못하다.
-ㄴ 확장에 있어 유연하지 못함.
-> 반면 컴포넌트 방식을 기능을 추가함으로 새로운 객체를 표현하기 때문에 상속 기반 방식보다 좀 더
유연한 클래스 구조 설계를 가능하게 한다.
-> 런타임에 극강한 장점을 얻을 수 있다.

-> 단점
-> 컴포넌트 방식을 객체를 표현하기 위한 기능, 각 클래스 별로 분리되어 있는 경우가 많기 때문에
컴포넌트간에 서로 협력 관계를 형성하기 위한 로직이 필연적으로 필요하다.
-> 이는 상속에 비해 많은 유연성을 제공하지만 퍼포먼스 측면에서는 좋지 않다.
-> 구현 난이도가 높다. (언리얼에서 어느정도 제공은 하지만 만들어보면 확장이 안되고, 오류수정하기 힘들것이다)
-> 런타임 자료형 오류가 발생할 순 있다.

▶언리얼 엔진에서의 컴포넌트 기반 프로그래밍
-> 언리얼 엔진은 컨테이너에 해당하는 게임 객체 (Actor)와 EngineCore 클래스를 통해 컴포넌트 방식을
제어하는 매커니즘으로 동작한다.
-> 일반적으로 언리얼의 메모리 관리 시스템부터 에디터와의 연동을 원한다면 반드시 UObject 파생 클래스를
직 / 간접적으로 상속해야지만 언리얼 객체상에 구동하는 것이 가능하다.


- 재질 (Material)
- 머터리얼은 기본적으로 Surface에 적용할 수 있는 미리 빌드된 비주얼 이펙트라고 할 수 있다.
ㄴ 텍스처 / 색상 / 거칠기 / 빛 등 모든 서피스 디테일에 관여할 수 있다.

-> 3D 외형을 설정하기 위한 주요 수단이라고 이해하면 좋겠다.
-> 여기서는 이미지 기반 반사부터 표현에 이르기까지 모든것을 머터리얼로 처리 할 수 있고, 셰이더 처리 또한
여기서 발생한다.
-> 재질 교체를 위해서는 머터리얼을 사용하자.

머터리얼, 모델, 애니메이션 이 3가지는 계속해서 괴롭힐 것이다.

선이 깜빡이는 이유
-> Z - Fighting
서로 동일한 위치값이 들어와, Depth를 지정해주지 않으면 서로 어떤게 렌더링이 될지 서로 렌더 하기 때문에 겹치는 선이 깜빡인다.
해결 방법.
1. 렌더링 우선 순위 부여 (추천하진 않음)
2. 컬링 (할 수 는 있지만 효율은 모르겠다)
3. 거리 확보 (
4. 정수 (정수값을 주면 Z-Fighting이 사라질것이다.)

Metalic-> 반사값.
Roughness -> 표면 거칠기.
ㆍRoughness (캐릭터를 불렀을때, 명암이 이상하게 들어가있으면 이게 설정 안되어있어서 그럴수 있다)
깊이감을 줄때 사용하는 속성

※ 기능적으로는 동일
-유니티
-> Smoothness
ㄴ 매끄러운 정도
-언리얼
Roughness
ㄴ 거칠기 정도 (1에 가까워 질수록 거칠어 진다.)

Mesh (3D -> 중요) (최적화)
1. V vertex -> S.M (Static Mesh) 정적 매쉬
 2D 정점 / 3D 정점
 (X,Y의 위치 좌표만 있음 / X, Y위치 부터 시작해서, UV 색상 등 여러 가지 정보를 가지고 있다)
2. E Edge (모서리)
3. P Polygon (면)
4. M Mesh  Polygon이 모여 만들어진것이 3D 공간상의 물체라고 할 수 있다.
흔들리는 나무, 풀 밭 -> 스태틱 매쉬임 (눈속임)

bsp란?
복셀, 오페인?

UV(언리얼) <-> 타일링(유니티) -> vertex(정점이 갖고있다)
-> Textrue -> 매핑에 쓰는 좌표계
UV 값으로 확대, 축소 반복, 미러링, 클래핑 을 할 것인지 설정할 수 있다.

정점의 Pos는 3차원, UV는 2차원.
3D UV를 만드려면 큐브차원이 필요하다.
텍스처의 UV값을 임의로 줄여서(ex) 0.5, 1) 사용하면, 그려질때는 다시 1, 1로 확장하기 때문에
텍스처의 색깔이 연해진다.
-> 리소스를 가져와서 텍스처를 매핑했을때 제대로 안나오면, UV값의 문제일 수 있다.

UV 주의사항
-> 확대 OK (면에 1장이 들어가서)
-> 축소에는 옵션을 지정해서 -> 컴퓨터에게 알려주어야 한다.
ㄴ 반복해서 바를지 / 밀어서 바를지 / 거울처럼 반사 시킬건지 / 아니면 색상으로 채울것인지
★
- DX + OpenGL (애니메이션에서도 자주 나올것이다)
ㄴ 랩(반복) / 클램프(비반복) / 보더(도장같이 찍겠다) /
미러(역으로 반사해서 바른다.) / 컬러 (남은 컬러 피커로 처리)


언리얼 조작
3인칭 캐릭터 만들기.
-> 콘텐츠 브라우저 -> 추가 -> 피처 또는 콘탠츠 팩 추가.
-> 삼인칭.
-> 추가 되었으면, 시작 버튼 왼쪽에 코드모양 누르기
-> 프로젝트 세팅 -> 게임모드Base클래스 선택 -> BP_ThirdPersonGameMode 
플레이어 안움직일경우) 시작 버튼 오른쪽 : 설정 눌러서 -> 선택된 뷰포트인지 확인.
-> 좌표를 안보고 싶으면 -> 표시 -> 그리드 체크 해제.

메테리얼 설정->
우클릭 -> VectorParam ->  Meterial_plane 채우기
우클릭 -> ScalarParam -> Metalic_plane 채우기
우클릭 -> ScalarParam -> Rouhness_Plane 채우기

*/
#pragma endregion